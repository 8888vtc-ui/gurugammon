
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model analyses
 * 
 */
export type analyses = $Result.DefaultSelection<Prisma.$analysesPayload>
/**
 * Model chat_messages
 * 
 */
export type chat_messages = $Result.DefaultSelection<Prisma.$chat_messagesPayload>
/**
 * Model game_moves
 * 
 */
export type game_moves = $Result.DefaultSelection<Prisma.$game_movesPayload>
/**
 * Model games
 * 
 */
export type games = $Result.DefaultSelection<Prisma.$gamesPayload>
/**
 * Model subscriptions
 * 
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>
/**
 * Model tournament_participants
 * 
 */
export type tournament_participants = $Result.DefaultSelection<Prisma.$tournament_participantsPayload>
/**
 * Model tournaments
 * 
 */
export type tournaments = $Result.DefaultSelection<Prisma.$tournamentsPayload>
/**
 * Model user_analytics
 * 
 */
export type user_analytics = $Result.DefaultSelection<Prisma.$user_analyticsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model websocket_connections
 * 
 */
export type websocket_connections = $Result.DefaultSelection<Prisma.$websocket_connectionsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AnalysisType: {
  FULL: 'FULL',
  HINT: 'HINT',
  EVALUATE: 'EVALUATE'
};

export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType]


export const MessageType: {
  TEXT: 'TEXT',
  EMOJI: 'EMOJI',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const Player: {
  WHITE: 'WHITE',
  BLACK: 'BLACK'
};

export type Player = (typeof Player)[keyof typeof Player]


export const GameStatus: {
  WAITING: 'WAITING',
  PLAYING: 'PLAYING',
  FINISHED: 'FINISHED',
  ABORTED: 'ABORTED'
};

export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus]


export const GameMode: {
  AI_VS_PLAYER: 'AI_VS_PLAYER',
  PLAYER_VS_PLAYER: 'PLAYER_VS_PLAYER',
  TOURNAMENT: 'TOURNAMENT'
};

export type GameMode = (typeof GameMode)[keyof typeof GameMode]


export const SubscriptionPlan: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM',
  VIP: 'VIP'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  PAST_DUE: 'PAST_DUE',
  UNPAID: 'UNPAID'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const TournamentStatus: {
  REGISTRATION: 'REGISTRATION',
  IN_PROGRESS: 'IN_PROGRESS',
  FINISHED: 'FINISHED',
  CANCELLED: 'CANCELLED'
};

export type TournamentStatus = (typeof TournamentStatus)[keyof typeof TournamentStatus]


export const Level: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
  EXPERT: 'EXPERT',
  MASTER: 'MASTER'
};

export type Level = (typeof Level)[keyof typeof Level]


export const SubscriptionType: {
  FREE: 'FREE',
  PREMIUM: 'PREMIUM',
  VIP: 'VIP'
};

export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType]

}

export type AnalysisType = $Enums.AnalysisType

export const AnalysisType: typeof $Enums.AnalysisType

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type Player = $Enums.Player

export const Player: typeof $Enums.Player

export type GameStatus = $Enums.GameStatus

export const GameStatus: typeof $Enums.GameStatus

export type GameMode = $Enums.GameMode

export const GameMode: typeof $Enums.GameMode

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type TournamentStatus = $Enums.TournamentStatus

export const TournamentStatus: typeof $Enums.TournamentStatus

export type Level = $Enums.Level

export const Level: typeof $Enums.Level

export type SubscriptionType = $Enums.SubscriptionType

export const SubscriptionType: typeof $Enums.SubscriptionType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Analyses
 * const analyses = await prisma.analyses.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Analyses
   * const analyses = await prisma.analyses.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.analyses`: Exposes CRUD operations for the **analyses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analyses
    * const analyses = await prisma.analyses.findMany()
    * ```
    */
  get analyses(): Prisma.analysesDelegate<ExtArgs>;

  /**
   * `prisma.chat_messages`: Exposes CRUD operations for the **chat_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_messages
    * const chat_messages = await prisma.chat_messages.findMany()
    * ```
    */
  get chat_messages(): Prisma.chat_messagesDelegate<ExtArgs>;

  /**
   * `prisma.game_moves`: Exposes CRUD operations for the **game_moves** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_moves
    * const game_moves = await prisma.game_moves.findMany()
    * ```
    */
  get game_moves(): Prisma.game_movesDelegate<ExtArgs>;

  /**
   * `prisma.games`: Exposes CRUD operations for the **games** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.games.findMany()
    * ```
    */
  get games(): Prisma.gamesDelegate<ExtArgs>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs>;

  /**
   * `prisma.tournament_participants`: Exposes CRUD operations for the **tournament_participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournament_participants
    * const tournament_participants = await prisma.tournament_participants.findMany()
    * ```
    */
  get tournament_participants(): Prisma.tournament_participantsDelegate<ExtArgs>;

  /**
   * `prisma.tournaments`: Exposes CRUD operations for the **tournaments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournaments.findMany()
    * ```
    */
  get tournaments(): Prisma.tournamentsDelegate<ExtArgs>;

  /**
   * `prisma.user_analytics`: Exposes CRUD operations for the **user_analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_analytics
    * const user_analytics = await prisma.user_analytics.findMany()
    * ```
    */
  get user_analytics(): Prisma.user_analyticsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.websocket_connections`: Exposes CRUD operations for the **websocket_connections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Websocket_connections
    * const websocket_connections = await prisma.websocket_connections.findMany()
    * ```
    */
  get websocket_connections(): Prisma.websocket_connectionsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    analyses: 'analyses',
    chat_messages: 'chat_messages',
    game_moves: 'game_moves',
    games: 'games',
    subscriptions: 'subscriptions',
    tournament_participants: 'tournament_participants',
    tournaments: 'tournaments',
    user_analytics: 'user_analytics',
    users: 'users',
    websocket_connections: 'websocket_connections'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "analyses" | "chat_messages" | "game_moves" | "games" | "subscriptions" | "tournament_participants" | "tournaments" | "user_analytics" | "users" | "websocket_connections"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      analyses: {
        payload: Prisma.$analysesPayload<ExtArgs>
        fields: Prisma.analysesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.analysesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.analysesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          findFirst: {
            args: Prisma.analysesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.analysesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          findMany: {
            args: Prisma.analysesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>[]
          }
          create: {
            args: Prisma.analysesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          createMany: {
            args: Prisma.analysesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.analysesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>[]
          }
          delete: {
            args: Prisma.analysesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          update: {
            args: Prisma.analysesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          deleteMany: {
            args: Prisma.analysesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.analysesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.analysesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analysesPayload>
          }
          aggregate: {
            args: Prisma.AnalysesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyses>
          }
          groupBy: {
            args: Prisma.analysesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysesGroupByOutputType>[]
          }
          count: {
            args: Prisma.analysesCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysesCountAggregateOutputType> | number
          }
        }
      }
      chat_messages: {
        payload: Prisma.$chat_messagesPayload<ExtArgs>
        fields: Prisma.chat_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findFirst: {
            args: Prisma.chat_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findMany: {
            args: Prisma.chat_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          create: {
            args: Prisma.chat_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          createMany: {
            args: Prisma.chat_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          delete: {
            args: Prisma.chat_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          update: {
            args: Prisma.chat_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          deleteMany: {
            args: Prisma.chat_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chat_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          aggregate: {
            args: Prisma.Chat_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_messages>
          }
          groupBy: {
            args: Prisma.chat_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesCountAggregateOutputType> | number
          }
        }
      }
      game_moves: {
        payload: Prisma.$game_movesPayload<ExtArgs>
        fields: Prisma.game_movesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_movesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_movesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          findFirst: {
            args: Prisma.game_movesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_movesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          findMany: {
            args: Prisma.game_movesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>[]
          }
          create: {
            args: Prisma.game_movesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          createMany: {
            args: Prisma.game_movesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.game_movesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>[]
          }
          delete: {
            args: Prisma.game_movesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          update: {
            args: Prisma.game_movesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          deleteMany: {
            args: Prisma.game_movesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_movesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.game_movesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_movesPayload>
          }
          aggregate: {
            args: Prisma.Game_movesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_moves>
          }
          groupBy: {
            args: Prisma.game_movesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_movesGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_movesCountArgs<ExtArgs>
            result: $Utils.Optional<Game_movesCountAggregateOutputType> | number
          }
        }
      }
      games: {
        payload: Prisma.$gamesPayload<ExtArgs>
        fields: Prisma.gamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gamesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gamesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          findFirst: {
            args: Prisma.gamesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gamesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          findMany: {
            args: Prisma.gamesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>[]
          }
          create: {
            args: Prisma.gamesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          createMany: {
            args: Prisma.gamesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gamesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>[]
          }
          delete: {
            args: Prisma.gamesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          update: {
            args: Prisma.gamesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          deleteMany: {
            args: Prisma.gamesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gamesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gamesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesPayload>
          }
          aggregate: {
            args: Prisma.GamesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGames>
          }
          groupBy: {
            args: Prisma.gamesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.gamesCountArgs<ExtArgs>
            result: $Utils.Optional<GamesCountAggregateOutputType> | number
          }
        }
      }
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>
        fields: Prisma.subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      tournament_participants: {
        payload: Prisma.$tournament_participantsPayload<ExtArgs>
        fields: Prisma.tournament_participantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournament_participantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournament_participantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          findFirst: {
            args: Prisma.tournament_participantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournament_participantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          findMany: {
            args: Prisma.tournament_participantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>[]
          }
          create: {
            args: Prisma.tournament_participantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          createMany: {
            args: Prisma.tournament_participantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournament_participantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>[]
          }
          delete: {
            args: Prisma.tournament_participantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          update: {
            args: Prisma.tournament_participantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          deleteMany: {
            args: Prisma.tournament_participantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournament_participantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tournament_participantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournament_participantsPayload>
          }
          aggregate: {
            args: Prisma.Tournament_participantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament_participants>
          }
          groupBy: {
            args: Prisma.tournament_participantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tournament_participantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournament_participantsCountArgs<ExtArgs>
            result: $Utils.Optional<Tournament_participantsCountAggregateOutputType> | number
          }
        }
      }
      tournaments: {
        payload: Prisma.$tournamentsPayload<ExtArgs>
        fields: Prisma.tournamentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          findFirst: {
            args: Prisma.tournamentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          findMany: {
            args: Prisma.tournamentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          create: {
            args: Prisma.tournamentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          createMany: {
            args: Prisma.tournamentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>[]
          }
          delete: {
            args: Prisma.tournamentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          update: {
            args: Prisma.tournamentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          deleteMany: {
            args: Prisma.tournamentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tournamentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentsPayload>
          }
          aggregate: {
            args: Prisma.TournamentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournaments>
          }
          groupBy: {
            args: Prisma.tournamentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentsCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentsCountAggregateOutputType> | number
          }
        }
      }
      user_analytics: {
        payload: Prisma.$user_analyticsPayload<ExtArgs>
        fields: Prisma.user_analyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_analyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_analyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          findFirst: {
            args: Prisma.user_analyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_analyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          findMany: {
            args: Prisma.user_analyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          create: {
            args: Prisma.user_analyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          createMany: {
            args: Prisma.user_analyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_analyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>[]
          }
          delete: {
            args: Prisma.user_analyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          update: {
            args: Prisma.user_analyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          deleteMany: {
            args: Prisma.user_analyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_analyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_analyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_analyticsPayload>
          }
          aggregate: {
            args: Prisma.User_analyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_analytics>
          }
          groupBy: {
            args: Prisma.user_analyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_analyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_analyticsCountArgs<ExtArgs>
            result: $Utils.Optional<User_analyticsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      websocket_connections: {
        payload: Prisma.$websocket_connectionsPayload<ExtArgs>
        fields: Prisma.websocket_connectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.websocket_connectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.websocket_connectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          findFirst: {
            args: Prisma.websocket_connectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.websocket_connectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          findMany: {
            args: Prisma.websocket_connectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>[]
          }
          create: {
            args: Prisma.websocket_connectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          createMany: {
            args: Prisma.websocket_connectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.websocket_connectionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>[]
          }
          delete: {
            args: Prisma.websocket_connectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          update: {
            args: Prisma.websocket_connectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          deleteMany: {
            args: Prisma.websocket_connectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.websocket_connectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.websocket_connectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$websocket_connectionsPayload>
          }
          aggregate: {
            args: Prisma.Websocket_connectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsocket_connections>
          }
          groupBy: {
            args: Prisma.websocket_connectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Websocket_connectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.websocket_connectionsCountArgs<ExtArgs>
            result: $Utils.Optional<Websocket_connectionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GamesCountOutputType
   */

  export type GamesCountOutputType = {
    chat_messages: number
    game_moves: number
    websocket_connections: number
  }

  export type GamesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | GamesCountOutputTypeCountChat_messagesArgs
    game_moves?: boolean | GamesCountOutputTypeCountGame_movesArgs
    websocket_connections?: boolean | GamesCountOutputTypeCountWebsocket_connectionsArgs
  }

  // Custom InputTypes
  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamesCountOutputType
     */
    select?: GamesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountChat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountGame_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_movesWhereInput
  }

  /**
   * GamesCountOutputType without action
   */
  export type GamesCountOutputTypeCountWebsocket_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: websocket_connectionsWhereInput
  }


  /**
   * Count Type TournamentsCountOutputType
   */

  export type TournamentsCountOutputType = {
    games: number
    tournament_participants: number
  }

  export type TournamentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | TournamentsCountOutputTypeCountGamesArgs
    tournament_participants?: boolean | TournamentsCountOutputTypeCountTournament_participantsArgs
  }

  // Custom InputTypes
  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentsCountOutputType
     */
    select?: TournamentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
  }

  /**
   * TournamentsCountOutputType without action
   */
  export type TournamentsCountOutputTypeCountTournament_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_participantsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    analyses: number
    chat_messages: number
    game_moves: number
    games_games_black_player_idTousers: number
    games_games_white_player_idTousers: number
    tournament_participants: number
    tournaments: number
    user_analytics: number
    websocket_connections: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | UsersCountOutputTypeCountAnalysesArgs
    chat_messages?: boolean | UsersCountOutputTypeCountChat_messagesArgs
    game_moves?: boolean | UsersCountOutputTypeCountGame_movesArgs
    games_games_black_player_idTousers?: boolean | UsersCountOutputTypeCountGames_games_black_player_idTousersArgs
    games_games_white_player_idTousers?: boolean | UsersCountOutputTypeCountGames_games_white_player_idTousersArgs
    tournament_participants?: boolean | UsersCountOutputTypeCountTournament_participantsArgs
    tournaments?: boolean | UsersCountOutputTypeCountTournamentsArgs
    user_analytics?: boolean | UsersCountOutputTypeCountUser_analyticsArgs
    websocket_connections?: boolean | UsersCountOutputTypeCountWebsocket_connectionsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analysesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGame_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_movesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGames_games_black_player_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGames_games_white_player_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTournament_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_participantsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_analyticsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWebsocket_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: websocket_connectionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model analyses
   */

  export type AggregateAnalyses = {
    _count: AnalysesCountAggregateOutputType | null
    _avg: AnalysesAvgAggregateOutputType | null
    _sum: AnalysesSumAggregateOutputType | null
    _min: AnalysesMinAggregateOutputType | null
    _max: AnalysesMaxAggregateOutputType | null
  }

  export type AnalysesAvgAggregateOutputType = {
    dice: number | null
    equity: number | null
    pr: number | null
  }

  export type AnalysesSumAggregateOutputType = {
    dice: number[]
    equity: number | null
    pr: number | null
  }

  export type AnalysesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    board_state: string | null
    move: string | null
    best_move: string | null
    equity: number | null
    pr: number | null
    explanation: string | null
    analysis_type: $Enums.AnalysisType | null
    createdAt: Date | null
  }

  export type AnalysesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    board_state: string | null
    move: string | null
    best_move: string | null
    equity: number | null
    pr: number | null
    explanation: string | null
    analysis_type: $Enums.AnalysisType | null
    createdAt: Date | null
  }

  export type AnalysesCountAggregateOutputType = {
    id: number
    user_id: number
    board_state: number
    dice: number
    move: number
    best_move: number
    equity: number
    pr: number
    explanation: number
    alternatives: number
    analysis_type: number
    createdAt: number
    _all: number
  }


  export type AnalysesAvgAggregateInputType = {
    dice?: true
    equity?: true
    pr?: true
  }

  export type AnalysesSumAggregateInputType = {
    dice?: true
    equity?: true
    pr?: true
  }

  export type AnalysesMinAggregateInputType = {
    id?: true
    user_id?: true
    board_state?: true
    move?: true
    best_move?: true
    equity?: true
    pr?: true
    explanation?: true
    analysis_type?: true
    createdAt?: true
  }

  export type AnalysesMaxAggregateInputType = {
    id?: true
    user_id?: true
    board_state?: true
    move?: true
    best_move?: true
    equity?: true
    pr?: true
    explanation?: true
    analysis_type?: true
    createdAt?: true
  }

  export type AnalysesCountAggregateInputType = {
    id?: true
    user_id?: true
    board_state?: true
    dice?: true
    move?: true
    best_move?: true
    equity?: true
    pr?: true
    explanation?: true
    alternatives?: true
    analysis_type?: true
    createdAt?: true
    _all?: true
  }

  export type AnalysesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analyses to aggregate.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned analyses
    **/
    _count?: true | AnalysesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysesMaxAggregateInputType
  }

  export type GetAnalysesAggregateType<T extends AnalysesAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyses[P]>
      : GetScalarType<T[P], AggregateAnalyses[P]>
  }




  export type analysesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analysesWhereInput
    orderBy?: analysesOrderByWithAggregationInput | analysesOrderByWithAggregationInput[]
    by: AnalysesScalarFieldEnum[] | AnalysesScalarFieldEnum
    having?: analysesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysesCountAggregateInputType | true
    _avg?: AnalysesAvgAggregateInputType
    _sum?: AnalysesSumAggregateInputType
    _min?: AnalysesMinAggregateInputType
    _max?: AnalysesMaxAggregateInputType
  }

  export type AnalysesGroupByOutputType = {
    id: string
    user_id: string
    board_state: string
    dice: number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives: JsonValue
    analysis_type: $Enums.AnalysisType
    createdAt: Date
    _count: AnalysesCountAggregateOutputType | null
    _avg: AnalysesAvgAggregateOutputType | null
    _sum: AnalysesSumAggregateOutputType | null
    _min: AnalysesMinAggregateOutputType | null
    _max: AnalysesMaxAggregateOutputType | null
  }

  type GetAnalysesGroupByPayload<T extends analysesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysesGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysesGroupByOutputType[P]>
        }
      >
    >


  export type analysesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    board_state?: boolean
    dice?: boolean
    move?: boolean
    best_move?: boolean
    equity?: boolean
    pr?: boolean
    explanation?: boolean
    alternatives?: boolean
    analysis_type?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyses"]>

  export type analysesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    board_state?: boolean
    dice?: boolean
    move?: boolean
    best_move?: boolean
    equity?: boolean
    pr?: boolean
    explanation?: boolean
    alternatives?: boolean
    analysis_type?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyses"]>

  export type analysesSelectScalar = {
    id?: boolean
    user_id?: boolean
    board_state?: boolean
    dice?: boolean
    move?: boolean
    best_move?: boolean
    equity?: boolean
    pr?: boolean
    explanation?: boolean
    alternatives?: boolean
    analysis_type?: boolean
    createdAt?: boolean
  }

  export type analysesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type analysesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $analysesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "analyses"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      board_state: string
      dice: number[]
      move: string
      best_move: string
      equity: number
      pr: number
      explanation: string
      alternatives: Prisma.JsonValue
      analysis_type: $Enums.AnalysisType
      createdAt: Date
    }, ExtArgs["result"]["analyses"]>
    composites: {}
  }

  type analysesGetPayload<S extends boolean | null | undefined | analysesDefaultArgs> = $Result.GetResult<Prisma.$analysesPayload, S>

  type analysesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<analysesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalysesCountAggregateInputType | true
    }

  export interface analysesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['analyses'], meta: { name: 'analyses' } }
    /**
     * Find zero or one Analyses that matches the filter.
     * @param {analysesFindUniqueArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends analysesFindUniqueArgs>(args: SelectSubset<T, analysesFindUniqueArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Analyses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {analysesFindUniqueOrThrowArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends analysesFindUniqueOrThrowArgs>(args: SelectSubset<T, analysesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesFindFirstArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends analysesFindFirstArgs>(args?: SelectSubset<T, analysesFindFirstArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Analyses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesFindFirstOrThrowArgs} args - Arguments to find a Analyses
     * @example
     * // Get one Analyses
     * const analyses = await prisma.analyses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends analysesFindFirstOrThrowArgs>(args?: SelectSubset<T, analysesFindFirstOrThrowArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analyses
     * const analyses = await prisma.analyses.findMany()
     * 
     * // Get first 10 Analyses
     * const analyses = await prisma.analyses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysesWithIdOnly = await prisma.analyses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends analysesFindManyArgs>(args?: SelectSubset<T, analysesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Analyses.
     * @param {analysesCreateArgs} args - Arguments to create a Analyses.
     * @example
     * // Create one Analyses
     * const Analyses = await prisma.analyses.create({
     *   data: {
     *     // ... data to create a Analyses
     *   }
     * })
     * 
     */
    create<T extends analysesCreateArgs>(args: SelectSubset<T, analysesCreateArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Analyses.
     * @param {analysesCreateManyArgs} args - Arguments to create many Analyses.
     * @example
     * // Create many Analyses
     * const analyses = await prisma.analyses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends analysesCreateManyArgs>(args?: SelectSubset<T, analysesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analyses and returns the data saved in the database.
     * @param {analysesCreateManyAndReturnArgs} args - Arguments to create many Analyses.
     * @example
     * // Create many Analyses
     * const analyses = await prisma.analyses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analyses and only return the `id`
     * const analysesWithIdOnly = await prisma.analyses.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends analysesCreateManyAndReturnArgs>(args?: SelectSubset<T, analysesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Analyses.
     * @param {analysesDeleteArgs} args - Arguments to delete one Analyses.
     * @example
     * // Delete one Analyses
     * const Analyses = await prisma.analyses.delete({
     *   where: {
     *     // ... filter to delete one Analyses
     *   }
     * })
     * 
     */
    delete<T extends analysesDeleteArgs>(args: SelectSubset<T, analysesDeleteArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Analyses.
     * @param {analysesUpdateArgs} args - Arguments to update one Analyses.
     * @example
     * // Update one Analyses
     * const analyses = await prisma.analyses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends analysesUpdateArgs>(args: SelectSubset<T, analysesUpdateArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Analyses.
     * @param {analysesDeleteManyArgs} args - Arguments to filter Analyses to delete.
     * @example
     * // Delete a few Analyses
     * const { count } = await prisma.analyses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends analysesDeleteManyArgs>(args?: SelectSubset<T, analysesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analyses
     * const analyses = await prisma.analyses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends analysesUpdateManyArgs>(args: SelectSubset<T, analysesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analyses.
     * @param {analysesUpsertArgs} args - Arguments to update or create a Analyses.
     * @example
     * // Update or create a Analyses
     * const analyses = await prisma.analyses.upsert({
     *   create: {
     *     // ... data to create a Analyses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analyses we want to update
     *   }
     * })
     */
    upsert<T extends analysesUpsertArgs>(args: SelectSubset<T, analysesUpsertArgs<ExtArgs>>): Prisma__analysesClient<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesCountArgs} args - Arguments to filter Analyses to count.
     * @example
     * // Count the number of Analyses
     * const count = await prisma.analyses.count({
     *   where: {
     *     // ... the filter for the Analyses we want to count
     *   }
     * })
    **/
    count<T extends analysesCountArgs>(
      args?: Subset<T, analysesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysesAggregateArgs>(args: Subset<T, AnalysesAggregateArgs>): Prisma.PrismaPromise<GetAnalysesAggregateType<T>>

    /**
     * Group by Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analysesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends analysesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: analysesGroupByArgs['orderBy'] }
        : { orderBy?: analysesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, analysesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the analyses model
   */
  readonly fields: analysesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for analyses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__analysesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the analyses model
   */ 
  interface analysesFieldRefs {
    readonly id: FieldRef<"analyses", 'String'>
    readonly user_id: FieldRef<"analyses", 'String'>
    readonly board_state: FieldRef<"analyses", 'String'>
    readonly dice: FieldRef<"analyses", 'Int[]'>
    readonly move: FieldRef<"analyses", 'String'>
    readonly best_move: FieldRef<"analyses", 'String'>
    readonly equity: FieldRef<"analyses", 'Float'>
    readonly pr: FieldRef<"analyses", 'Float'>
    readonly explanation: FieldRef<"analyses", 'String'>
    readonly alternatives: FieldRef<"analyses", 'Json'>
    readonly analysis_type: FieldRef<"analyses", 'AnalysisType'>
    readonly createdAt: FieldRef<"analyses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * analyses findUnique
   */
  export type analysesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses findUniqueOrThrow
   */
  export type analysesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses findFirst
   */
  export type analysesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analyses.
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analyses.
     */
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * analyses findFirstOrThrow
   */
  export type analysesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analyses.
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analyses.
     */
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * analyses findMany
   */
  export type analysesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter, which analyses to fetch.
     */
    where?: analysesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analyses to fetch.
     */
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing analyses.
     */
    cursor?: analysesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analyses.
     */
    skip?: number
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * analyses create
   */
  export type analysesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * The data needed to create a analyses.
     */
    data: XOR<analysesCreateInput, analysesUncheckedCreateInput>
  }

  /**
   * analyses createMany
   */
  export type analysesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many analyses.
     */
    data: analysesCreateManyInput | analysesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * analyses createManyAndReturn
   */
  export type analysesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many analyses.
     */
    data: analysesCreateManyInput | analysesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * analyses update
   */
  export type analysesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * The data needed to update a analyses.
     */
    data: XOR<analysesUpdateInput, analysesUncheckedUpdateInput>
    /**
     * Choose, which analyses to update.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses updateMany
   */
  export type analysesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update analyses.
     */
    data: XOR<analysesUpdateManyMutationInput, analysesUncheckedUpdateManyInput>
    /**
     * Filter which analyses to update
     */
    where?: analysesWhereInput
  }

  /**
   * analyses upsert
   */
  export type analysesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * The filter to search for the analyses to update in case it exists.
     */
    where: analysesWhereUniqueInput
    /**
     * In case the analyses found by the `where` argument doesn't exist, create a new analyses with this data.
     */
    create: XOR<analysesCreateInput, analysesUncheckedCreateInput>
    /**
     * In case the analyses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<analysesUpdateInput, analysesUncheckedUpdateInput>
  }

  /**
   * analyses delete
   */
  export type analysesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    /**
     * Filter which analyses to delete.
     */
    where: analysesWhereUniqueInput
  }

  /**
   * analyses deleteMany
   */
  export type analysesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analyses to delete
     */
    where?: analysesWhereInput
  }

  /**
   * analyses without action
   */
  export type analysesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
  }


  /**
   * Model chat_messages
   */

  export type AggregateChat_messages = {
    _count: Chat_messagesCountAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  export type Chat_messagesMinAggregateOutputType = {
    id: string | null
    game_id: string | null
    user_id: string | null
    message: string | null
    message_type: $Enums.MessageType | null
    createdAt: Date | null
  }

  export type Chat_messagesMaxAggregateOutputType = {
    id: string | null
    game_id: string | null
    user_id: string | null
    message: string | null
    message_type: $Enums.MessageType | null
    createdAt: Date | null
  }

  export type Chat_messagesCountAggregateOutputType = {
    id: number
    game_id: number
    user_id: number
    message: number
    message_type: number
    createdAt: number
    _all: number
  }


  export type Chat_messagesMinAggregateInputType = {
    id?: true
    game_id?: true
    user_id?: true
    message?: true
    message_type?: true
    createdAt?: true
  }

  export type Chat_messagesMaxAggregateInputType = {
    id?: true
    game_id?: true
    user_id?: true
    message?: true
    message_type?: true
    createdAt?: true
  }

  export type Chat_messagesCountAggregateInputType = {
    id?: true
    game_id?: true
    user_id?: true
    message?: true
    message_type?: true
    createdAt?: true
    _all?: true
  }

  export type Chat_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to aggregate.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_messages
    **/
    _count?: true | Chat_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type GetChat_messagesAggregateType<T extends Chat_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_messages[P]>
      : GetScalarType<T[P], AggregateChat_messages[P]>
  }




  export type chat_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithAggregationInput | chat_messagesOrderByWithAggregationInput[]
    by: Chat_messagesScalarFieldEnum[] | Chat_messagesScalarFieldEnum
    having?: chat_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_messagesCountAggregateInputType | true
    _min?: Chat_messagesMinAggregateInputType
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type Chat_messagesGroupByOutputType = {
    id: string
    game_id: string
    user_id: string | null
    message: string
    message_type: $Enums.MessageType
    createdAt: Date
    _count: Chat_messagesCountAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  type GetChat_messagesGroupByPayload<T extends chat_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
        }
      >
    >


  export type chat_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    game_id?: boolean
    user_id?: boolean
    message?: boolean
    message_type?: boolean
    createdAt?: boolean
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    game_id?: boolean
    user_id?: boolean
    message?: boolean
    message_type?: boolean
    createdAt?: boolean
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectScalar = {
    id?: boolean
    game_id?: boolean
    user_id?: boolean
    message?: boolean
    message_type?: boolean
    createdAt?: boolean
  }

  export type chat_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }
  export type chat_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | chat_messages$usersArgs<ExtArgs>
  }

  export type $chat_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_messages"
    objects: {
      games: Prisma.$gamesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      game_id: string
      user_id: string | null
      message: string
      message_type: $Enums.MessageType
      createdAt: Date
    }, ExtArgs["result"]["chat_messages"]>
    composites: {}
  }

  type chat_messagesGetPayload<S extends boolean | null | undefined | chat_messagesDefaultArgs> = $Result.GetResult<Prisma.$chat_messagesPayload, S>

  type chat_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<chat_messagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Chat_messagesCountAggregateInputType | true
    }

  export interface chat_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_messages'], meta: { name: 'chat_messages' } }
    /**
     * Find zero or one Chat_messages that matches the filter.
     * @param {chat_messagesFindUniqueArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_messagesFindUniqueArgs>(args: SelectSubset<T, chat_messagesFindUniqueArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat_messages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {chat_messagesFindUniqueOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_messagesFindFirstArgs>(args?: SelectSubset<T, chat_messagesFindFirstArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany()
     * 
     * // Get first 10 Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_messagesFindManyArgs>(args?: SelectSubset<T, chat_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat_messages.
     * @param {chat_messagesCreateArgs} args - Arguments to create a Chat_messages.
     * @example
     * // Create one Chat_messages
     * const Chat_messages = await prisma.chat_messages.create({
     *   data: {
     *     // ... data to create a Chat_messages
     *   }
     * })
     * 
     */
    create<T extends chat_messagesCreateArgs>(args: SelectSubset<T, chat_messagesCreateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chat_messages.
     * @param {chat_messagesCreateManyArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_messagesCreateManyArgs>(args?: SelectSubset<T, chat_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_messages and returns the data saved in the database.
     * @param {chat_messagesCreateManyAndReturnArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat_messages.
     * @param {chat_messagesDeleteArgs} args - Arguments to delete one Chat_messages.
     * @example
     * // Delete one Chat_messages
     * const Chat_messages = await prisma.chat_messages.delete({
     *   where: {
     *     // ... filter to delete one Chat_messages
     *   }
     * })
     * 
     */
    delete<T extends chat_messagesDeleteArgs>(args: SelectSubset<T, chat_messagesDeleteArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat_messages.
     * @param {chat_messagesUpdateArgs} args - Arguments to update one Chat_messages.
     * @example
     * // Update one Chat_messages
     * const chat_messages = await prisma.chat_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_messagesUpdateArgs>(args: SelectSubset<T, chat_messagesUpdateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chat_messages.
     * @param {chat_messagesDeleteManyArgs} args - Arguments to filter Chat_messages to delete.
     * @example
     * // Delete a few Chat_messages
     * const { count } = await prisma.chat_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_messagesDeleteManyArgs>(args?: SelectSubset<T, chat_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_messagesUpdateManyArgs>(args: SelectSubset<T, chat_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat_messages.
     * @param {chat_messagesUpsertArgs} args - Arguments to update or create a Chat_messages.
     * @example
     * // Update or create a Chat_messages
     * const chat_messages = await prisma.chat_messages.upsert({
     *   create: {
     *     // ... data to create a Chat_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_messages we want to update
     *   }
     * })
     */
    upsert<T extends chat_messagesUpsertArgs>(args: SelectSubset<T, chat_messagesUpsertArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesCountArgs} args - Arguments to filter Chat_messages to count.
     * @example
     * // Count the number of Chat_messages
     * const count = await prisma.chat_messages.count({
     *   where: {
     *     // ... the filter for the Chat_messages we want to count
     *   }
     * })
    **/
    count<T extends chat_messagesCountArgs>(
      args?: Subset<T, chat_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_messagesAggregateArgs>(args: Subset<T, Chat_messagesAggregateArgs>): Prisma.PrismaPromise<GetChat_messagesAggregateType<T>>

    /**
     * Group by Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_messagesGroupByArgs['orderBy'] }
        : { orderBy?: chat_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_messages model
   */
  readonly fields: chat_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends chat_messages$usersArgs<ExtArgs> = {}>(args?: Subset<T, chat_messages$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_messages model
   */ 
  interface chat_messagesFieldRefs {
    readonly id: FieldRef<"chat_messages", 'String'>
    readonly game_id: FieldRef<"chat_messages", 'String'>
    readonly user_id: FieldRef<"chat_messages", 'String'>
    readonly message: FieldRef<"chat_messages", 'String'>
    readonly message_type: FieldRef<"chat_messages", 'MessageType'>
    readonly createdAt: FieldRef<"chat_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chat_messages findUnique
   */
  export type chat_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findUniqueOrThrow
   */
  export type chat_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findFirst
   */
  export type chat_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findFirstOrThrow
   */
  export type chat_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findMany
   */
  export type chat_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages create
   */
  export type chat_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_messages.
     */
    data: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
  }

  /**
   * chat_messages createMany
   */
  export type chat_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_messages createManyAndReturn
   */
  export type chat_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages update
   */
  export type chat_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_messages.
     */
    data: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
    /**
     * Choose, which chat_messages to update.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages updateMany
   */
  export type chat_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
  }

  /**
   * chat_messages upsert
   */
  export type chat_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_messages to update in case it exists.
     */
    where: chat_messagesWhereUniqueInput
    /**
     * In case the chat_messages found by the `where` argument doesn't exist, create a new chat_messages with this data.
     */
    create: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
    /**
     * In case the chat_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
  }

  /**
   * chat_messages delete
   */
  export type chat_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter which chat_messages to delete.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages deleteMany
   */
  export type chat_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to delete
     */
    where?: chat_messagesWhereInput
  }

  /**
   * chat_messages.users
   */
  export type chat_messages$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * chat_messages without action
   */
  export type chat_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
  }


  /**
   * Model game_moves
   */

  export type AggregateGame_moves = {
    _count: Game_movesCountAggregateOutputType | null
    _avg: Game_movesAvgAggregateOutputType | null
    _sum: Game_movesSumAggregateOutputType | null
    _min: Game_movesMinAggregateOutputType | null
    _max: Game_movesMaxAggregateOutputType | null
  }

  export type Game_movesAvgAggregateOutputType = {
    dice: number | null
    from_point: number | null
    to_point: number | null
    equity: number | null
    pr: number | null
    thinking_time: number | null
  }

  export type Game_movesSumAggregateOutputType = {
    dice: number[]
    from_point: number | null
    to_point: number | null
    equity: number | null
    pr: number | null
    thinking_time: number | null
  }

  export type Game_movesMinAggregateOutputType = {
    id: string | null
    game_id: string | null
    user_id: string | null
    player: $Enums.Player | null
    move: string | null
    from_point: number | null
    to_point: number | null
    equity: number | null
    pr: number | null
    thinking_time: number | null
    createdAt: Date | null
  }

  export type Game_movesMaxAggregateOutputType = {
    id: string | null
    game_id: string | null
    user_id: string | null
    player: $Enums.Player | null
    move: string | null
    from_point: number | null
    to_point: number | null
    equity: number | null
    pr: number | null
    thinking_time: number | null
    createdAt: Date | null
  }

  export type Game_movesCountAggregateOutputType = {
    id: number
    game_id: number
    user_id: number
    player: number
    dice: number
    move: number
    from_point: number
    to_point: number
    equity: number
    pr: number
    thinking_time: number
    createdAt: number
    _all: number
  }


  export type Game_movesAvgAggregateInputType = {
    dice?: true
    from_point?: true
    to_point?: true
    equity?: true
    pr?: true
    thinking_time?: true
  }

  export type Game_movesSumAggregateInputType = {
    dice?: true
    from_point?: true
    to_point?: true
    equity?: true
    pr?: true
    thinking_time?: true
  }

  export type Game_movesMinAggregateInputType = {
    id?: true
    game_id?: true
    user_id?: true
    player?: true
    move?: true
    from_point?: true
    to_point?: true
    equity?: true
    pr?: true
    thinking_time?: true
    createdAt?: true
  }

  export type Game_movesMaxAggregateInputType = {
    id?: true
    game_id?: true
    user_id?: true
    player?: true
    move?: true
    from_point?: true
    to_point?: true
    equity?: true
    pr?: true
    thinking_time?: true
    createdAt?: true
  }

  export type Game_movesCountAggregateInputType = {
    id?: true
    game_id?: true
    user_id?: true
    player?: true
    dice?: true
    move?: true
    from_point?: true
    to_point?: true
    equity?: true
    pr?: true
    thinking_time?: true
    createdAt?: true
    _all?: true
  }

  export type Game_movesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_moves to aggregate.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_moves
    **/
    _count?: true | Game_movesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_movesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_movesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_movesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_movesMaxAggregateInputType
  }

  export type GetGame_movesAggregateType<T extends Game_movesAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_moves]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_moves[P]>
      : GetScalarType<T[P], AggregateGame_moves[P]>
  }




  export type game_movesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_movesWhereInput
    orderBy?: game_movesOrderByWithAggregationInput | game_movesOrderByWithAggregationInput[]
    by: Game_movesScalarFieldEnum[] | Game_movesScalarFieldEnum
    having?: game_movesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_movesCountAggregateInputType | true
    _avg?: Game_movesAvgAggregateInputType
    _sum?: Game_movesSumAggregateInputType
    _min?: Game_movesMinAggregateInputType
    _max?: Game_movesMaxAggregateInputType
  }

  export type Game_movesGroupByOutputType = {
    id: string
    game_id: string
    user_id: string | null
    player: $Enums.Player
    dice: number[]
    move: string
    from_point: number | null
    to_point: number | null
    equity: number | null
    pr: number | null
    thinking_time: number | null
    createdAt: Date
    _count: Game_movesCountAggregateOutputType | null
    _avg: Game_movesAvgAggregateOutputType | null
    _sum: Game_movesSumAggregateOutputType | null
    _min: Game_movesMinAggregateOutputType | null
    _max: Game_movesMaxAggregateOutputType | null
  }

  type GetGame_movesGroupByPayload<T extends game_movesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_movesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_movesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_movesGroupByOutputType[P]>
            : GetScalarType<T[P], Game_movesGroupByOutputType[P]>
        }
      >
    >


  export type game_movesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    game_id?: boolean
    user_id?: boolean
    player?: boolean
    dice?: boolean
    move?: boolean
    from_point?: boolean
    to_point?: boolean
    equity?: boolean
    pr?: boolean
    thinking_time?: boolean
    createdAt?: boolean
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | game_moves$usersArgs<ExtArgs>
  }, ExtArgs["result"]["game_moves"]>

  export type game_movesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    game_id?: boolean
    user_id?: boolean
    player?: boolean
    dice?: boolean
    move?: boolean
    from_point?: boolean
    to_point?: boolean
    equity?: boolean
    pr?: boolean
    thinking_time?: boolean
    createdAt?: boolean
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | game_moves$usersArgs<ExtArgs>
  }, ExtArgs["result"]["game_moves"]>

  export type game_movesSelectScalar = {
    id?: boolean
    game_id?: boolean
    user_id?: boolean
    player?: boolean
    dice?: boolean
    move?: boolean
    from_point?: boolean
    to_point?: boolean
    equity?: boolean
    pr?: boolean
    thinking_time?: boolean
    createdAt?: boolean
  }

  export type game_movesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | game_moves$usersArgs<ExtArgs>
  }
  export type game_movesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | gamesDefaultArgs<ExtArgs>
    users?: boolean | game_moves$usersArgs<ExtArgs>
  }

  export type $game_movesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_moves"
    objects: {
      games: Prisma.$gamesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      game_id: string
      user_id: string | null
      player: $Enums.Player
      dice: number[]
      move: string
      from_point: number | null
      to_point: number | null
      equity: number | null
      pr: number | null
      thinking_time: number | null
      createdAt: Date
    }, ExtArgs["result"]["game_moves"]>
    composites: {}
  }

  type game_movesGetPayload<S extends boolean | null | undefined | game_movesDefaultArgs> = $Result.GetResult<Prisma.$game_movesPayload, S>

  type game_movesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<game_movesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Game_movesCountAggregateInputType | true
    }

  export interface game_movesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_moves'], meta: { name: 'game_moves' } }
    /**
     * Find zero or one Game_moves that matches the filter.
     * @param {game_movesFindUniqueArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_movesFindUniqueArgs>(args: SelectSubset<T, game_movesFindUniqueArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game_moves that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {game_movesFindUniqueOrThrowArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_movesFindUniqueOrThrowArgs>(args: SelectSubset<T, game_movesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game_moves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesFindFirstArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_movesFindFirstArgs>(args?: SelectSubset<T, game_movesFindFirstArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game_moves that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesFindFirstOrThrowArgs} args - Arguments to find a Game_moves
     * @example
     * // Get one Game_moves
     * const game_moves = await prisma.game_moves.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_movesFindFirstOrThrowArgs>(args?: SelectSubset<T, game_movesFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Game_moves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_moves
     * const game_moves = await prisma.game_moves.findMany()
     * 
     * // Get first 10 Game_moves
     * const game_moves = await prisma.game_moves.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_movesWithIdOnly = await prisma.game_moves.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends game_movesFindManyArgs>(args?: SelectSubset<T, game_movesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game_moves.
     * @param {game_movesCreateArgs} args - Arguments to create a Game_moves.
     * @example
     * // Create one Game_moves
     * const Game_moves = await prisma.game_moves.create({
     *   data: {
     *     // ... data to create a Game_moves
     *   }
     * })
     * 
     */
    create<T extends game_movesCreateArgs>(args: SelectSubset<T, game_movesCreateArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Game_moves.
     * @param {game_movesCreateManyArgs} args - Arguments to create many Game_moves.
     * @example
     * // Create many Game_moves
     * const game_moves = await prisma.game_moves.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_movesCreateManyArgs>(args?: SelectSubset<T, game_movesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Game_moves and returns the data saved in the database.
     * @param {game_movesCreateManyAndReturnArgs} args - Arguments to create many Game_moves.
     * @example
     * // Create many Game_moves
     * const game_moves = await prisma.game_moves.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Game_moves and only return the `id`
     * const game_movesWithIdOnly = await prisma.game_moves.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends game_movesCreateManyAndReturnArgs>(args?: SelectSubset<T, game_movesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game_moves.
     * @param {game_movesDeleteArgs} args - Arguments to delete one Game_moves.
     * @example
     * // Delete one Game_moves
     * const Game_moves = await prisma.game_moves.delete({
     *   where: {
     *     // ... filter to delete one Game_moves
     *   }
     * })
     * 
     */
    delete<T extends game_movesDeleteArgs>(args: SelectSubset<T, game_movesDeleteArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game_moves.
     * @param {game_movesUpdateArgs} args - Arguments to update one Game_moves.
     * @example
     * // Update one Game_moves
     * const game_moves = await prisma.game_moves.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_movesUpdateArgs>(args: SelectSubset<T, game_movesUpdateArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Game_moves.
     * @param {game_movesDeleteManyArgs} args - Arguments to filter Game_moves to delete.
     * @example
     * // Delete a few Game_moves
     * const { count } = await prisma.game_moves.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_movesDeleteManyArgs>(args?: SelectSubset<T, game_movesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_moves
     * const game_moves = await prisma.game_moves.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_movesUpdateManyArgs>(args: SelectSubset<T, game_movesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game_moves.
     * @param {game_movesUpsertArgs} args - Arguments to update or create a Game_moves.
     * @example
     * // Update or create a Game_moves
     * const game_moves = await prisma.game_moves.upsert({
     *   create: {
     *     // ... data to create a Game_moves
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_moves we want to update
     *   }
     * })
     */
    upsert<T extends game_movesUpsertArgs>(args: SelectSubset<T, game_movesUpsertArgs<ExtArgs>>): Prisma__game_movesClient<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesCountArgs} args - Arguments to filter Game_moves to count.
     * @example
     * // Count the number of Game_moves
     * const count = await prisma.game_moves.count({
     *   where: {
     *     // ... the filter for the Game_moves we want to count
     *   }
     * })
    **/
    count<T extends game_movesCountArgs>(
      args?: Subset<T, game_movesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_movesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_movesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_movesAggregateArgs>(args: Subset<T, Game_movesAggregateArgs>): Prisma.PrismaPromise<GetGame_movesAggregateType<T>>

    /**
     * Group by Game_moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_movesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_movesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_movesGroupByArgs['orderBy'] }
        : { orderBy?: game_movesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_movesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_movesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_moves model
   */
  readonly fields: game_movesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_moves.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_movesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends gamesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, gamesDefaultArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends game_moves$usersArgs<ExtArgs> = {}>(args?: Subset<T, game_moves$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_moves model
   */ 
  interface game_movesFieldRefs {
    readonly id: FieldRef<"game_moves", 'String'>
    readonly game_id: FieldRef<"game_moves", 'String'>
    readonly user_id: FieldRef<"game_moves", 'String'>
    readonly player: FieldRef<"game_moves", 'Player'>
    readonly dice: FieldRef<"game_moves", 'Int[]'>
    readonly move: FieldRef<"game_moves", 'String'>
    readonly from_point: FieldRef<"game_moves", 'Int'>
    readonly to_point: FieldRef<"game_moves", 'Int'>
    readonly equity: FieldRef<"game_moves", 'Float'>
    readonly pr: FieldRef<"game_moves", 'Float'>
    readonly thinking_time: FieldRef<"game_moves", 'Int'>
    readonly createdAt: FieldRef<"game_moves", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * game_moves findUnique
   */
  export type game_movesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves findUniqueOrThrow
   */
  export type game_movesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves findFirst
   */
  export type game_movesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_moves.
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_moves.
     */
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * game_moves findFirstOrThrow
   */
  export type game_movesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_moves.
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_moves.
     */
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * game_moves findMany
   */
  export type game_movesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter, which game_moves to fetch.
     */
    where?: game_movesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_moves to fetch.
     */
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_moves.
     */
    cursor?: game_movesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_moves.
     */
    skip?: number
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * game_moves create
   */
  export type game_movesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * The data needed to create a game_moves.
     */
    data: XOR<game_movesCreateInput, game_movesUncheckedCreateInput>
  }

  /**
   * game_moves createMany
   */
  export type game_movesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_moves.
     */
    data: game_movesCreateManyInput | game_movesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_moves createManyAndReturn
   */
  export type game_movesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many game_moves.
     */
    data: game_movesCreateManyInput | game_movesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * game_moves update
   */
  export type game_movesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * The data needed to update a game_moves.
     */
    data: XOR<game_movesUpdateInput, game_movesUncheckedUpdateInput>
    /**
     * Choose, which game_moves to update.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves updateMany
   */
  export type game_movesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_moves.
     */
    data: XOR<game_movesUpdateManyMutationInput, game_movesUncheckedUpdateManyInput>
    /**
     * Filter which game_moves to update
     */
    where?: game_movesWhereInput
  }

  /**
   * game_moves upsert
   */
  export type game_movesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * The filter to search for the game_moves to update in case it exists.
     */
    where: game_movesWhereUniqueInput
    /**
     * In case the game_moves found by the `where` argument doesn't exist, create a new game_moves with this data.
     */
    create: XOR<game_movesCreateInput, game_movesUncheckedCreateInput>
    /**
     * In case the game_moves was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_movesUpdateInput, game_movesUncheckedUpdateInput>
  }

  /**
   * game_moves delete
   */
  export type game_movesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    /**
     * Filter which game_moves to delete.
     */
    where: game_movesWhereUniqueInput
  }

  /**
   * game_moves deleteMany
   */
  export type game_movesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_moves to delete
     */
    where?: game_movesWhereInput
  }

  /**
   * game_moves.users
   */
  export type game_moves$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * game_moves without action
   */
  export type game_movesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
  }


  /**
   * Model games
   */

  export type AggregateGames = {
    _count: GamesCountAggregateOutputType | null
    _avg: GamesAvgAggregateOutputType | null
    _sum: GamesSumAggregateOutputType | null
    _min: GamesMinAggregateOutputType | null
    _max: GamesMaxAggregateOutputType | null
  }

  export type GamesAvgAggregateOutputType = {
    dice: number | null
    white_score: number | null
    black_score: number | null
  }

  export type GamesSumAggregateOutputType = {
    dice: number[]
    white_score: number | null
    black_score: number | null
  }

  export type GamesMinAggregateOutputType = {
    id: string | null
    white_player_id: string | null
    black_player_id: string | null
    status: $Enums.GameStatus | null
    board_state: string | null
    gameMode: $Enums.GameMode | null
    current_player: $Enums.Player | null
    white_score: number | null
    black_score: number | null
    createdAt: Date | null
    finished_at: Date | null
    winner: $Enums.Player | null
    tournament_id: string | null
  }

  export type GamesMaxAggregateOutputType = {
    id: string | null
    white_player_id: string | null
    black_player_id: string | null
    status: $Enums.GameStatus | null
    board_state: string | null
    gameMode: $Enums.GameMode | null
    current_player: $Enums.Player | null
    white_score: number | null
    black_score: number | null
    createdAt: Date | null
    finished_at: Date | null
    winner: $Enums.Player | null
    tournament_id: string | null
  }

  export type GamesCountAggregateOutputType = {
    id: number
    white_player_id: number
    black_player_id: number
    status: number
    board_state: number
    gameMode: number
    current_player: number
    dice: number
    white_score: number
    black_score: number
    createdAt: number
    finished_at: number
    winner: number
    tournament_id: number
    _all: number
  }


  export type GamesAvgAggregateInputType = {
    dice?: true
    white_score?: true
    black_score?: true
  }

  export type GamesSumAggregateInputType = {
    dice?: true
    white_score?: true
    black_score?: true
  }

  export type GamesMinAggregateInputType = {
    id?: true
    white_player_id?: true
    black_player_id?: true
    status?: true
    board_state?: true
    gameMode?: true
    current_player?: true
    white_score?: true
    black_score?: true
    createdAt?: true
    finished_at?: true
    winner?: true
    tournament_id?: true
  }

  export type GamesMaxAggregateInputType = {
    id?: true
    white_player_id?: true
    black_player_id?: true
    status?: true
    board_state?: true
    gameMode?: true
    current_player?: true
    white_score?: true
    black_score?: true
    createdAt?: true
    finished_at?: true
    winner?: true
    tournament_id?: true
  }

  export type GamesCountAggregateInputType = {
    id?: true
    white_player_id?: true
    black_player_id?: true
    status?: true
    board_state?: true
    gameMode?: true
    current_player?: true
    dice?: true
    white_score?: true
    black_score?: true
    createdAt?: true
    finished_at?: true
    winner?: true
    tournament_id?: true
    _all?: true
  }

  export type GamesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which games to aggregate.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned games
    **/
    _count?: true | GamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamesMaxAggregateInputType
  }

  export type GetGamesAggregateType<T extends GamesAggregateArgs> = {
        [P in keyof T & keyof AggregateGames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGames[P]>
      : GetScalarType<T[P], AggregateGames[P]>
  }




  export type gamesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithAggregationInput | gamesOrderByWithAggregationInput[]
    by: GamesScalarFieldEnum[] | GamesScalarFieldEnum
    having?: gamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamesCountAggregateInputType | true
    _avg?: GamesAvgAggregateInputType
    _sum?: GamesSumAggregateInputType
    _min?: GamesMinAggregateInputType
    _max?: GamesMaxAggregateInputType
  }

  export type GamesGroupByOutputType = {
    id: string
    white_player_id: string | null
    black_player_id: string | null
    status: $Enums.GameStatus
    board_state: string
    gameMode: $Enums.GameMode
    current_player: $Enums.Player
    dice: number[]
    white_score: number
    black_score: number
    createdAt: Date
    finished_at: Date | null
    winner: $Enums.Player | null
    tournament_id: string | null
    _count: GamesCountAggregateOutputType | null
    _avg: GamesAvgAggregateOutputType | null
    _sum: GamesSumAggregateOutputType | null
    _min: GamesMinAggregateOutputType | null
    _max: GamesMaxAggregateOutputType | null
  }

  type GetGamesGroupByPayload<T extends gamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamesGroupByOutputType[P]>
            : GetScalarType<T[P], GamesGroupByOutputType[P]>
        }
      >
    >


  export type gamesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    white_player_id?: boolean
    black_player_id?: boolean
    status?: boolean
    board_state?: boolean
    gameMode?: boolean
    current_player?: boolean
    dice?: boolean
    white_score?: boolean
    black_score?: boolean
    createdAt?: boolean
    finished_at?: boolean
    winner?: boolean
    tournament_id?: boolean
    chat_messages?: boolean | games$chat_messagesArgs<ExtArgs>
    game_moves?: boolean | games$game_movesArgs<ExtArgs>
    users_games_black_player_idTousers?: boolean | games$users_games_black_player_idTousersArgs<ExtArgs>
    tournaments?: boolean | games$tournamentsArgs<ExtArgs>
    users_games_white_player_idTousers?: boolean | games$users_games_white_player_idTousersArgs<ExtArgs>
    websocket_connections?: boolean | games$websocket_connectionsArgs<ExtArgs>
    _count?: boolean | GamesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["games"]>

  export type gamesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    white_player_id?: boolean
    black_player_id?: boolean
    status?: boolean
    board_state?: boolean
    gameMode?: boolean
    current_player?: boolean
    dice?: boolean
    white_score?: boolean
    black_score?: boolean
    createdAt?: boolean
    finished_at?: boolean
    winner?: boolean
    tournament_id?: boolean
    users_games_black_player_idTousers?: boolean | games$users_games_black_player_idTousersArgs<ExtArgs>
    tournaments?: boolean | games$tournamentsArgs<ExtArgs>
    users_games_white_player_idTousers?: boolean | games$users_games_white_player_idTousersArgs<ExtArgs>
  }, ExtArgs["result"]["games"]>

  export type gamesSelectScalar = {
    id?: boolean
    white_player_id?: boolean
    black_player_id?: boolean
    status?: boolean
    board_state?: boolean
    gameMode?: boolean
    current_player?: boolean
    dice?: boolean
    white_score?: boolean
    black_score?: boolean
    createdAt?: boolean
    finished_at?: boolean
    winner?: boolean
    tournament_id?: boolean
  }

  export type gamesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | games$chat_messagesArgs<ExtArgs>
    game_moves?: boolean | games$game_movesArgs<ExtArgs>
    users_games_black_player_idTousers?: boolean | games$users_games_black_player_idTousersArgs<ExtArgs>
    tournaments?: boolean | games$tournamentsArgs<ExtArgs>
    users_games_white_player_idTousers?: boolean | games$users_games_white_player_idTousersArgs<ExtArgs>
    websocket_connections?: boolean | games$websocket_connectionsArgs<ExtArgs>
    _count?: boolean | GamesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type gamesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_games_black_player_idTousers?: boolean | games$users_games_black_player_idTousersArgs<ExtArgs>
    tournaments?: boolean | games$tournamentsArgs<ExtArgs>
    users_games_white_player_idTousers?: boolean | games$users_games_white_player_idTousersArgs<ExtArgs>
  }

  export type $gamesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "games"
    objects: {
      chat_messages: Prisma.$chat_messagesPayload<ExtArgs>[]
      game_moves: Prisma.$game_movesPayload<ExtArgs>[]
      users_games_black_player_idTousers: Prisma.$usersPayload<ExtArgs> | null
      tournaments: Prisma.$tournamentsPayload<ExtArgs> | null
      users_games_white_player_idTousers: Prisma.$usersPayload<ExtArgs> | null
      websocket_connections: Prisma.$websocket_connectionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      white_player_id: string | null
      black_player_id: string | null
      status: $Enums.GameStatus
      board_state: string
      gameMode: $Enums.GameMode
      current_player: $Enums.Player
      dice: number[]
      white_score: number
      black_score: number
      createdAt: Date
      finished_at: Date | null
      winner: $Enums.Player | null
      tournament_id: string | null
    }, ExtArgs["result"]["games"]>
    composites: {}
  }

  type gamesGetPayload<S extends boolean | null | undefined | gamesDefaultArgs> = $Result.GetResult<Prisma.$gamesPayload, S>

  type gamesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<gamesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamesCountAggregateInputType | true
    }

  export interface gamesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['games'], meta: { name: 'games' } }
    /**
     * Find zero or one Games that matches the filter.
     * @param {gamesFindUniqueArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gamesFindUniqueArgs>(args: SelectSubset<T, gamesFindUniqueArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Games that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {gamesFindUniqueOrThrowArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gamesFindUniqueOrThrowArgs>(args: SelectSubset<T, gamesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesFindFirstArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gamesFindFirstArgs>(args?: SelectSubset<T, gamesFindFirstArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Games that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesFindFirstOrThrowArgs} args - Arguments to find a Games
     * @example
     * // Get one Games
     * const games = await prisma.games.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gamesFindFirstOrThrowArgs>(args?: SelectSubset<T, gamesFindFirstOrThrowArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.games.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.games.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamesWithIdOnly = await prisma.games.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gamesFindManyArgs>(args?: SelectSubset<T, gamesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Games.
     * @param {gamesCreateArgs} args - Arguments to create a Games.
     * @example
     * // Create one Games
     * const Games = await prisma.games.create({
     *   data: {
     *     // ... data to create a Games
     *   }
     * })
     * 
     */
    create<T extends gamesCreateArgs>(args: SelectSubset<T, gamesCreateArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Games.
     * @param {gamesCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const games = await prisma.games.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gamesCreateManyArgs>(args?: SelectSubset<T, gamesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {gamesCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const games = await prisma.games.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gamesWithIdOnly = await prisma.games.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gamesCreateManyAndReturnArgs>(args?: SelectSubset<T, gamesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Games.
     * @param {gamesDeleteArgs} args - Arguments to delete one Games.
     * @example
     * // Delete one Games
     * const Games = await prisma.games.delete({
     *   where: {
     *     // ... filter to delete one Games
     *   }
     * })
     * 
     */
    delete<T extends gamesDeleteArgs>(args: SelectSubset<T, gamesDeleteArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Games.
     * @param {gamesUpdateArgs} args - Arguments to update one Games.
     * @example
     * // Update one Games
     * const games = await prisma.games.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gamesUpdateArgs>(args: SelectSubset<T, gamesUpdateArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {gamesDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.games.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gamesDeleteManyArgs>(args?: SelectSubset<T, gamesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const games = await prisma.games.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gamesUpdateManyArgs>(args: SelectSubset<T, gamesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Games.
     * @param {gamesUpsertArgs} args - Arguments to update or create a Games.
     * @example
     * // Update or create a Games
     * const games = await prisma.games.upsert({
     *   create: {
     *     // ... data to create a Games
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Games we want to update
     *   }
     * })
     */
    upsert<T extends gamesUpsertArgs>(args: SelectSubset<T, gamesUpsertArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.games.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends gamesCountArgs>(
      args?: Subset<T, gamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamesAggregateArgs>(args: Subset<T, GamesAggregateArgs>): Prisma.PrismaPromise<GetGamesAggregateType<T>>

    /**
     * Group by Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gamesGroupByArgs['orderBy'] }
        : { orderBy?: gamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the games model
   */
  readonly fields: gamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for games.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gamesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_messages<T extends games$chat_messagesArgs<ExtArgs> = {}>(args?: Subset<T, games$chat_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany"> | Null>
    game_moves<T extends games$game_movesArgs<ExtArgs> = {}>(args?: Subset<T, games$game_movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findMany"> | Null>
    users_games_black_player_idTousers<T extends games$users_games_black_player_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, games$users_games_black_player_idTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tournaments<T extends games$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, games$tournamentsArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users_games_white_player_idTousers<T extends games$users_games_white_player_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, games$users_games_white_player_idTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    websocket_connections<T extends games$websocket_connectionsArgs<ExtArgs> = {}>(args?: Subset<T, games$websocket_connectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the games model
   */ 
  interface gamesFieldRefs {
    readonly id: FieldRef<"games", 'String'>
    readonly white_player_id: FieldRef<"games", 'String'>
    readonly black_player_id: FieldRef<"games", 'String'>
    readonly status: FieldRef<"games", 'GameStatus'>
    readonly board_state: FieldRef<"games", 'String'>
    readonly gameMode: FieldRef<"games", 'GameMode'>
    readonly current_player: FieldRef<"games", 'Player'>
    readonly dice: FieldRef<"games", 'Int[]'>
    readonly white_score: FieldRef<"games", 'Int'>
    readonly black_score: FieldRef<"games", 'Int'>
    readonly createdAt: FieldRef<"games", 'DateTime'>
    readonly finished_at: FieldRef<"games", 'DateTime'>
    readonly winner: FieldRef<"games", 'Player'>
    readonly tournament_id: FieldRef<"games", 'String'>
  }
    

  // Custom InputTypes
  /**
   * games findUnique
   */
  export type gamesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games findUniqueOrThrow
   */
  export type gamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games findFirst
   */
  export type gamesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * games findFirstOrThrow
   */
  export type gamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for games.
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of games.
     */
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * games findMany
   */
  export type gamesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter, which games to fetch.
     */
    where?: gamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of games to fetch.
     */
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing games.
     */
    cursor?: gamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` games.
     */
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * games create
   */
  export type gamesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * The data needed to create a games.
     */
    data: XOR<gamesCreateInput, gamesUncheckedCreateInput>
  }

  /**
   * games createMany
   */
  export type gamesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many games.
     */
    data: gamesCreateManyInput | gamesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * games createManyAndReturn
   */
  export type gamesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many games.
     */
    data: gamesCreateManyInput | gamesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * games update
   */
  export type gamesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * The data needed to update a games.
     */
    data: XOR<gamesUpdateInput, gamesUncheckedUpdateInput>
    /**
     * Choose, which games to update.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games updateMany
   */
  export type gamesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update games.
     */
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyInput>
    /**
     * Filter which games to update
     */
    where?: gamesWhereInput
  }

  /**
   * games upsert
   */
  export type gamesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * The filter to search for the games to update in case it exists.
     */
    where: gamesWhereUniqueInput
    /**
     * In case the games found by the `where` argument doesn't exist, create a new games with this data.
     */
    create: XOR<gamesCreateInput, gamesUncheckedCreateInput>
    /**
     * In case the games was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gamesUpdateInput, gamesUncheckedUpdateInput>
  }

  /**
   * games delete
   */
  export type gamesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    /**
     * Filter which games to delete.
     */
    where: gamesWhereUniqueInput
  }

  /**
   * games deleteMany
   */
  export type gamesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which games to delete
     */
    where?: gamesWhereInput
  }

  /**
   * games.chat_messages
   */
  export type games$chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * games.game_moves
   */
  export type games$game_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    where?: game_movesWhereInput
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    cursor?: game_movesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * games.users_games_black_player_idTousers
   */
  export type games$users_games_black_player_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * games.tournaments
   */
  export type games$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    where?: tournamentsWhereInput
  }

  /**
   * games.users_games_white_player_idTousers
   */
  export type games$users_games_white_player_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * games.websocket_connections
   */
  export type games$websocket_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    where?: websocket_connectionsWhereInput
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    cursor?: websocket_connectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * games without action
   */
  export type gamesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
  }


  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    stripe_subscription_id: string | null
    stripe_customer_id: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    stripe_subscription_id: string | null
    stripe_customer_id: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    user_id: number
    stripe_subscription_id: number
    stripe_customer_id: number
    plan: number
    status: number
    current_period_start: number
    current_period_end: number
    cancel_at_period_end: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionsMinAggregateInputType = {
    id?: true
    user_id?: true
    stripe_subscription_id?: true
    stripe_customer_id?: true
    plan?: true
    status?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    stripe_subscription_id?: true
    stripe_customer_id?: true
    plan?: true
    status?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    user_id?: true
    stripe_subscription_id?: true
    stripe_customer_id?: true
    plan?: true
    status?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: string
    user_id: string
    stripe_subscription_id: string | null
    stripe_customer_id: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stripe_subscription_id?: boolean
    stripe_customer_id?: boolean
    plan?: boolean
    status?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stripe_subscription_id?: boolean
    stripe_customer_id?: boolean
    plan?: boolean
    status?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    stripe_subscription_id?: boolean
    stripe_customer_id?: boolean
    plan?: boolean
    status?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type subscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      stripe_subscription_id: string | null
      stripe_customer_id: string | null
      plan: $Enums.SubscriptionPlan
      status: $Enums.SubscriptionStatus
      current_period_start: Date | null
      current_period_end: Date | null
      cancel_at_period_end: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$subscriptionsPayload, S>

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<subscriptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'], meta: { name: 'subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionsFindManyArgs>(args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends subscriptionsCreateArgs>(args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionsCreateManyArgs>(args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, subscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends subscriptionsDeleteArgs>(args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionsUpdateArgs>(args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscriptions model
   */
  readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscriptions model
   */ 
  interface subscriptionsFieldRefs {
    readonly id: FieldRef<"subscriptions", 'String'>
    readonly user_id: FieldRef<"subscriptions", 'String'>
    readonly stripe_subscription_id: FieldRef<"subscriptions", 'String'>
    readonly stripe_customer_id: FieldRef<"subscriptions", 'String'>
    readonly plan: FieldRef<"subscriptions", 'SubscriptionPlan'>
    readonly status: FieldRef<"subscriptions", 'SubscriptionStatus'>
    readonly current_period_start: FieldRef<"subscriptions", 'DateTime'>
    readonly current_period_end: FieldRef<"subscriptions", 'DateTime'>
    readonly cancel_at_period_end: FieldRef<"subscriptions", 'Boolean'>
    readonly createdAt: FieldRef<"subscriptions", 'DateTime'>
    readonly updatedAt: FieldRef<"subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
  }

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscriptions createManyAndReturn
   */
  export type subscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
  }

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
  }

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput
  }

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model tournament_participants
   */

  export type AggregateTournament_participants = {
    _count: Tournament_participantsCountAggregateOutputType | null
    _avg: Tournament_participantsAvgAggregateOutputType | null
    _sum: Tournament_participantsSumAggregateOutputType | null
    _min: Tournament_participantsMinAggregateOutputType | null
    _max: Tournament_participantsMaxAggregateOutputType | null
  }

  export type Tournament_participantsAvgAggregateOutputType = {
    current_position: number | null
  }

  export type Tournament_participantsSumAggregateOutputType = {
    current_position: number | null
  }

  export type Tournament_participantsMinAggregateOutputType = {
    id: string | null
    tournament_id: string | null
    user_id: string | null
    registered_at: Date | null
    current_position: number | null
    eliminated_at: Date | null
  }

  export type Tournament_participantsMaxAggregateOutputType = {
    id: string | null
    tournament_id: string | null
    user_id: string | null
    registered_at: Date | null
    current_position: number | null
    eliminated_at: Date | null
  }

  export type Tournament_participantsCountAggregateOutputType = {
    id: number
    tournament_id: number
    user_id: number
    registered_at: number
    current_position: number
    eliminated_at: number
    _all: number
  }


  export type Tournament_participantsAvgAggregateInputType = {
    current_position?: true
  }

  export type Tournament_participantsSumAggregateInputType = {
    current_position?: true
  }

  export type Tournament_participantsMinAggregateInputType = {
    id?: true
    tournament_id?: true
    user_id?: true
    registered_at?: true
    current_position?: true
    eliminated_at?: true
  }

  export type Tournament_participantsMaxAggregateInputType = {
    id?: true
    tournament_id?: true
    user_id?: true
    registered_at?: true
    current_position?: true
    eliminated_at?: true
  }

  export type Tournament_participantsCountAggregateInputType = {
    id?: true
    tournament_id?: true
    user_id?: true
    registered_at?: true
    current_position?: true
    eliminated_at?: true
    _all?: true
  }

  export type Tournament_participantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament_participants to aggregate.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournament_participants
    **/
    _count?: true | Tournament_participantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tournament_participantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tournament_participantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tournament_participantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tournament_participantsMaxAggregateInputType
  }

  export type GetTournament_participantsAggregateType<T extends Tournament_participantsAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament_participants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament_participants[P]>
      : GetScalarType<T[P], AggregateTournament_participants[P]>
  }




  export type tournament_participantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournament_participantsWhereInput
    orderBy?: tournament_participantsOrderByWithAggregationInput | tournament_participantsOrderByWithAggregationInput[]
    by: Tournament_participantsScalarFieldEnum[] | Tournament_participantsScalarFieldEnum
    having?: tournament_participantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tournament_participantsCountAggregateInputType | true
    _avg?: Tournament_participantsAvgAggregateInputType
    _sum?: Tournament_participantsSumAggregateInputType
    _min?: Tournament_participantsMinAggregateInputType
    _max?: Tournament_participantsMaxAggregateInputType
  }

  export type Tournament_participantsGroupByOutputType = {
    id: string
    tournament_id: string
    user_id: string
    registered_at: Date
    current_position: number | null
    eliminated_at: Date | null
    _count: Tournament_participantsCountAggregateOutputType | null
    _avg: Tournament_participantsAvgAggregateOutputType | null
    _sum: Tournament_participantsSumAggregateOutputType | null
    _min: Tournament_participantsMinAggregateOutputType | null
    _max: Tournament_participantsMaxAggregateOutputType | null
  }

  type GetTournament_participantsGroupByPayload<T extends tournament_participantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tournament_participantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tournament_participantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tournament_participantsGroupByOutputType[P]>
            : GetScalarType<T[P], Tournament_participantsGroupByOutputType[P]>
        }
      >
    >


  export type tournament_participantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournament_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    current_position?: boolean
    eliminated_at?: boolean
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament_participants"]>

  export type tournament_participantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournament_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    current_position?: boolean
    eliminated_at?: boolean
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament_participants"]>

  export type tournament_participantsSelectScalar = {
    id?: boolean
    tournament_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    current_position?: boolean
    eliminated_at?: boolean
  }

  export type tournament_participantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type tournament_participantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournaments?: boolean | tournamentsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $tournament_participantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournament_participants"
    objects: {
      tournaments: Prisma.$tournamentsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournament_id: string
      user_id: string
      registered_at: Date
      current_position: number | null
      eliminated_at: Date | null
    }, ExtArgs["result"]["tournament_participants"]>
    composites: {}
  }

  type tournament_participantsGetPayload<S extends boolean | null | undefined | tournament_participantsDefaultArgs> = $Result.GetResult<Prisma.$tournament_participantsPayload, S>

  type tournament_participantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tournament_participantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tournament_participantsCountAggregateInputType | true
    }

  export interface tournament_participantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournament_participants'], meta: { name: 'tournament_participants' } }
    /**
     * Find zero or one Tournament_participants that matches the filter.
     * @param {tournament_participantsFindUniqueArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournament_participantsFindUniqueArgs>(args: SelectSubset<T, tournament_participantsFindUniqueArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournament_participants that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tournament_participantsFindUniqueOrThrowArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournament_participantsFindUniqueOrThrowArgs>(args: SelectSubset<T, tournament_participantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournament_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsFindFirstArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournament_participantsFindFirstArgs>(args?: SelectSubset<T, tournament_participantsFindFirstArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournament_participants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsFindFirstOrThrowArgs} args - Arguments to find a Tournament_participants
     * @example
     * // Get one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournament_participantsFindFirstOrThrowArgs>(args?: SelectSubset<T, tournament_participantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournament_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findMany()
     * 
     * // Get first 10 Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournament_participantsWithIdOnly = await prisma.tournament_participants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournament_participantsFindManyArgs>(args?: SelectSubset<T, tournament_participantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournament_participants.
     * @param {tournament_participantsCreateArgs} args - Arguments to create a Tournament_participants.
     * @example
     * // Create one Tournament_participants
     * const Tournament_participants = await prisma.tournament_participants.create({
     *   data: {
     *     // ... data to create a Tournament_participants
     *   }
     * })
     * 
     */
    create<T extends tournament_participantsCreateArgs>(args: SelectSubset<T, tournament_participantsCreateArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournament_participants.
     * @param {tournament_participantsCreateManyArgs} args - Arguments to create many Tournament_participants.
     * @example
     * // Create many Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournament_participantsCreateManyArgs>(args?: SelectSubset<T, tournament_participantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournament_participants and returns the data saved in the database.
     * @param {tournament_participantsCreateManyAndReturnArgs} args - Arguments to create many Tournament_participants.
     * @example
     * // Create many Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournament_participants and only return the `id`
     * const tournament_participantsWithIdOnly = await prisma.tournament_participants.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournament_participantsCreateManyAndReturnArgs>(args?: SelectSubset<T, tournament_participantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournament_participants.
     * @param {tournament_participantsDeleteArgs} args - Arguments to delete one Tournament_participants.
     * @example
     * // Delete one Tournament_participants
     * const Tournament_participants = await prisma.tournament_participants.delete({
     *   where: {
     *     // ... filter to delete one Tournament_participants
     *   }
     * })
     * 
     */
    delete<T extends tournament_participantsDeleteArgs>(args: SelectSubset<T, tournament_participantsDeleteArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournament_participants.
     * @param {tournament_participantsUpdateArgs} args - Arguments to update one Tournament_participants.
     * @example
     * // Update one Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournament_participantsUpdateArgs>(args: SelectSubset<T, tournament_participantsUpdateArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournament_participants.
     * @param {tournament_participantsDeleteManyArgs} args - Arguments to filter Tournament_participants to delete.
     * @example
     * // Delete a few Tournament_participants
     * const { count } = await prisma.tournament_participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournament_participantsDeleteManyArgs>(args?: SelectSubset<T, tournament_participantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournament_participantsUpdateManyArgs>(args: SelectSubset<T, tournament_participantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournament_participants.
     * @param {tournament_participantsUpsertArgs} args - Arguments to update or create a Tournament_participants.
     * @example
     * // Update or create a Tournament_participants
     * const tournament_participants = await prisma.tournament_participants.upsert({
     *   create: {
     *     // ... data to create a Tournament_participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament_participants we want to update
     *   }
     * })
     */
    upsert<T extends tournament_participantsUpsertArgs>(args: SelectSubset<T, tournament_participantsUpsertArgs<ExtArgs>>): Prisma__tournament_participantsClient<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsCountArgs} args - Arguments to filter Tournament_participants to count.
     * @example
     * // Count the number of Tournament_participants
     * const count = await prisma.tournament_participants.count({
     *   where: {
     *     // ... the filter for the Tournament_participants we want to count
     *   }
     * })
    **/
    count<T extends tournament_participantsCountArgs>(
      args?: Subset<T, tournament_participantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tournament_participantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tournament_participantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tournament_participantsAggregateArgs>(args: Subset<T, Tournament_participantsAggregateArgs>): Prisma.PrismaPromise<GetTournament_participantsAggregateType<T>>

    /**
     * Group by Tournament_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournament_participantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournament_participantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournament_participantsGroupByArgs['orderBy'] }
        : { orderBy?: tournament_participantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournament_participantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournament_participantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournament_participants model
   */
  readonly fields: tournament_participantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournament_participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournament_participantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournaments<T extends tournamentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentsDefaultArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournament_participants model
   */ 
  interface tournament_participantsFieldRefs {
    readonly id: FieldRef<"tournament_participants", 'String'>
    readonly tournament_id: FieldRef<"tournament_participants", 'String'>
    readonly user_id: FieldRef<"tournament_participants", 'String'>
    readonly registered_at: FieldRef<"tournament_participants", 'DateTime'>
    readonly current_position: FieldRef<"tournament_participants", 'Int'>
    readonly eliminated_at: FieldRef<"tournament_participants", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tournament_participants findUnique
   */
  export type tournament_participantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants findUniqueOrThrow
   */
  export type tournament_participantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants findFirst
   */
  export type tournament_participantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournament_participants.
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournament_participants.
     */
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournament_participants findFirstOrThrow
   */
  export type tournament_participantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournament_participants.
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournament_participants.
     */
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournament_participants findMany
   */
  export type tournament_participantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter, which tournament_participants to fetch.
     */
    where?: tournament_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournament_participants to fetch.
     */
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournament_participants.
     */
    cursor?: tournament_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournament_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournament_participants.
     */
    skip?: number
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournament_participants create
   */
  export type tournament_participantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * The data needed to create a tournament_participants.
     */
    data: XOR<tournament_participantsCreateInput, tournament_participantsUncheckedCreateInput>
  }

  /**
   * tournament_participants createMany
   */
  export type tournament_participantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournament_participants.
     */
    data: tournament_participantsCreateManyInput | tournament_participantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournament_participants createManyAndReturn
   */
  export type tournament_participantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tournament_participants.
     */
    data: tournament_participantsCreateManyInput | tournament_participantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament_participants update
   */
  export type tournament_participantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * The data needed to update a tournament_participants.
     */
    data: XOR<tournament_participantsUpdateInput, tournament_participantsUncheckedUpdateInput>
    /**
     * Choose, which tournament_participants to update.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants updateMany
   */
  export type tournament_participantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournament_participants.
     */
    data: XOR<tournament_participantsUpdateManyMutationInput, tournament_participantsUncheckedUpdateManyInput>
    /**
     * Filter which tournament_participants to update
     */
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_participants upsert
   */
  export type tournament_participantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * The filter to search for the tournament_participants to update in case it exists.
     */
    where: tournament_participantsWhereUniqueInput
    /**
     * In case the tournament_participants found by the `where` argument doesn't exist, create a new tournament_participants with this data.
     */
    create: XOR<tournament_participantsCreateInput, tournament_participantsUncheckedCreateInput>
    /**
     * In case the tournament_participants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournament_participantsUpdateInput, tournament_participantsUncheckedUpdateInput>
  }

  /**
   * tournament_participants delete
   */
  export type tournament_participantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    /**
     * Filter which tournament_participants to delete.
     */
    where: tournament_participantsWhereUniqueInput
  }

  /**
   * tournament_participants deleteMany
   */
  export type tournament_participantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament_participants to delete
     */
    where?: tournament_participantsWhereInput
  }

  /**
   * tournament_participants without action
   */
  export type tournament_participantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
  }


  /**
   * Model tournaments
   */

  export type AggregateTournaments = {
    _count: TournamentsCountAggregateOutputType | null
    _avg: TournamentsAvgAggregateOutputType | null
    _sum: TournamentsSumAggregateOutputType | null
    _min: TournamentsMinAggregateOutputType | null
    _max: TournamentsMaxAggregateOutputType | null
  }

  export type TournamentsAvgAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
  }

  export type TournamentsSumAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
  }

  export type TournamentsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
    status: $Enums.TournamentStatus | null
    start_time: Date | null
    end_time: Date | null
    created_by: string | null
    createdAt: Date | null
  }

  export type TournamentsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    entryFee: number | null
    prizePool: number | null
    maxPlayers: number | null
    status: $Enums.TournamentStatus | null
    start_time: Date | null
    end_time: Date | null
    created_by: string | null
    createdAt: Date | null
  }

  export type TournamentsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    entryFee: number
    prizePool: number
    maxPlayers: number
    status: number
    start_time: number
    end_time: number
    created_by: number
    createdAt: number
    _all: number
  }


  export type TournamentsAvgAggregateInputType = {
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
  }

  export type TournamentsSumAggregateInputType = {
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
  }

  export type TournamentsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
    status?: true
    start_time?: true
    end_time?: true
    created_by?: true
    createdAt?: true
  }

  export type TournamentsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
    status?: true
    start_time?: true
    end_time?: true
    created_by?: true
    createdAt?: true
  }

  export type TournamentsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    entryFee?: true
    prizePool?: true
    maxPlayers?: true
    status?: true
    start_time?: true
    end_time?: true
    created_by?: true
    createdAt?: true
    _all?: true
  }

  export type TournamentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to aggregate.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournaments
    **/
    _count?: true | TournamentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentsMaxAggregateInputType
  }

  export type GetTournamentsAggregateType<T extends TournamentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTournaments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournaments[P]>
      : GetScalarType<T[P], AggregateTournaments[P]>
  }




  export type tournamentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentsWhereInput
    orderBy?: tournamentsOrderByWithAggregationInput | tournamentsOrderByWithAggregationInput[]
    by: TournamentsScalarFieldEnum[] | TournamentsScalarFieldEnum
    having?: tournamentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentsCountAggregateInputType | true
    _avg?: TournamentsAvgAggregateInputType
    _sum?: TournamentsSumAggregateInputType
    _min?: TournamentsMinAggregateInputType
    _max?: TournamentsMaxAggregateInputType
  }

  export type TournamentsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    entryFee: number
    prizePool: number
    maxPlayers: number | null
    status: $Enums.TournamentStatus
    start_time: Date | null
    end_time: Date | null
    created_by: string
    createdAt: Date
    _count: TournamentsCountAggregateOutputType | null
    _avg: TournamentsAvgAggregateOutputType | null
    _sum: TournamentsSumAggregateOutputType | null
    _min: TournamentsMinAggregateOutputType | null
    _max: TournamentsMaxAggregateOutputType | null
  }

  type GetTournamentsGroupByPayload<T extends tournamentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentsGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentsGroupByOutputType[P]>
        }
      >
    >


  export type tournamentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    entryFee?: boolean
    prizePool?: boolean
    maxPlayers?: boolean
    status?: boolean
    start_time?: boolean
    end_time?: boolean
    created_by?: boolean
    createdAt?: boolean
    games?: boolean | tournaments$gamesArgs<ExtArgs>
    tournament_participants?: boolean | tournaments$tournament_participantsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TournamentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    entryFee?: boolean
    prizePool?: boolean
    maxPlayers?: boolean
    status?: boolean
    start_time?: boolean
    end_time?: boolean
    created_by?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournaments"]>

  export type tournamentsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    entryFee?: boolean
    prizePool?: boolean
    maxPlayers?: boolean
    status?: boolean
    start_time?: boolean
    end_time?: boolean
    created_by?: boolean
    createdAt?: boolean
  }

  export type tournamentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | tournaments$gamesArgs<ExtArgs>
    tournament_participants?: boolean | tournaments$tournament_participantsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TournamentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tournamentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $tournamentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournaments"
    objects: {
      games: Prisma.$gamesPayload<ExtArgs>[]
      tournament_participants: Prisma.$tournament_participantsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      entryFee: number
      prizePool: number
      maxPlayers: number | null
      status: $Enums.TournamentStatus
      start_time: Date | null
      end_time: Date | null
      created_by: string
      createdAt: Date
    }, ExtArgs["result"]["tournaments"]>
    composites: {}
  }

  type tournamentsGetPayload<S extends boolean | null | undefined | tournamentsDefaultArgs> = $Result.GetResult<Prisma.$tournamentsPayload, S>

  type tournamentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tournamentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamentsCountAggregateInputType | true
    }

  export interface tournamentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournaments'], meta: { name: 'tournaments' } }
    /**
     * Find zero or one Tournaments that matches the filter.
     * @param {tournamentsFindUniqueArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentsFindUniqueArgs>(args: SelectSubset<T, tournamentsFindUniqueArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournaments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tournamentsFindUniqueOrThrowArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentsFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindFirstArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentsFindFirstArgs>(args?: SelectSubset<T, tournamentsFindFirstArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournaments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindFirstOrThrowArgs} args - Arguments to find a Tournaments
     * @example
     * // Get one Tournaments
     * const tournaments = await prisma.tournaments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentsFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournaments.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournaments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentsFindManyArgs>(args?: SelectSubset<T, tournamentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournaments.
     * @param {tournamentsCreateArgs} args - Arguments to create a Tournaments.
     * @example
     * // Create one Tournaments
     * const Tournaments = await prisma.tournaments.create({
     *   data: {
     *     // ... data to create a Tournaments
     *   }
     * })
     * 
     */
    create<T extends tournamentsCreateArgs>(args: SelectSubset<T, tournamentsCreateArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournaments.
     * @param {tournamentsCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournaments = await prisma.tournaments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentsCreateManyArgs>(args?: SelectSubset<T, tournamentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {tournamentsCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournaments = await prisma.tournaments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentsWithIdOnly = await prisma.tournaments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentsCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournaments.
     * @param {tournamentsDeleteArgs} args - Arguments to delete one Tournaments.
     * @example
     * // Delete one Tournaments
     * const Tournaments = await prisma.tournaments.delete({
     *   where: {
     *     // ... filter to delete one Tournaments
     *   }
     * })
     * 
     */
    delete<T extends tournamentsDeleteArgs>(args: SelectSubset<T, tournamentsDeleteArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournaments.
     * @param {tournamentsUpdateArgs} args - Arguments to update one Tournaments.
     * @example
     * // Update one Tournaments
     * const tournaments = await prisma.tournaments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentsUpdateArgs>(args: SelectSubset<T, tournamentsUpdateArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournaments.
     * @param {tournamentsDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournaments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentsDeleteManyArgs>(args?: SelectSubset<T, tournamentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournaments = await prisma.tournaments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentsUpdateManyArgs>(args: SelectSubset<T, tournamentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournaments.
     * @param {tournamentsUpsertArgs} args - Arguments to update or create a Tournaments.
     * @example
     * // Update or create a Tournaments
     * const tournaments = await prisma.tournaments.upsert({
     *   create: {
     *     // ... data to create a Tournaments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournaments we want to update
     *   }
     * })
     */
    upsert<T extends tournamentsUpsertArgs>(args: SelectSubset<T, tournamentsUpsertArgs<ExtArgs>>): Prisma__tournamentsClient<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournaments.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends tournamentsCountArgs>(
      args?: Subset<T, tournamentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentsAggregateArgs>(args: Subset<T, TournamentsAggregateArgs>): Prisma.PrismaPromise<GetTournamentsAggregateType<T>>

    /**
     * Group by Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentsGroupByArgs['orderBy'] }
        : { orderBy?: tournamentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournaments model
   */
  readonly fields: tournamentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournaments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends tournaments$gamesArgs<ExtArgs> = {}>(args?: Subset<T, tournaments$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany"> | Null>
    tournament_participants<T extends tournaments$tournament_participantsArgs<ExtArgs> = {}>(args?: Subset<T, tournaments$tournament_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournaments model
   */ 
  interface tournamentsFieldRefs {
    readonly id: FieldRef<"tournaments", 'String'>
    readonly name: FieldRef<"tournaments", 'String'>
    readonly description: FieldRef<"tournaments", 'String'>
    readonly entryFee: FieldRef<"tournaments", 'Int'>
    readonly prizePool: FieldRef<"tournaments", 'Int'>
    readonly maxPlayers: FieldRef<"tournaments", 'Int'>
    readonly status: FieldRef<"tournaments", 'TournamentStatus'>
    readonly start_time: FieldRef<"tournaments", 'DateTime'>
    readonly end_time: FieldRef<"tournaments", 'DateTime'>
    readonly created_by: FieldRef<"tournaments", 'String'>
    readonly createdAt: FieldRef<"tournaments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tournaments findUnique
   */
  export type tournamentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments findUniqueOrThrow
   */
  export type tournamentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments findFirst
   */
  export type tournamentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments findFirstOrThrow
   */
  export type tournamentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments findMany
   */
  export type tournamentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournaments.
     */
    cursor?: tournamentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * tournaments create
   */
  export type tournamentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * The data needed to create a tournaments.
     */
    data: XOR<tournamentsCreateInput, tournamentsUncheckedCreateInput>
  }

  /**
   * tournaments createMany
   */
  export type tournamentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournaments.
     */
    data: tournamentsCreateManyInput | tournamentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournaments createManyAndReturn
   */
  export type tournamentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tournaments.
     */
    data: tournamentsCreateManyInput | tournamentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournaments update
   */
  export type tournamentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * The data needed to update a tournaments.
     */
    data: XOR<tournamentsUpdateInput, tournamentsUncheckedUpdateInput>
    /**
     * Choose, which tournaments to update.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments updateMany
   */
  export type tournamentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentsUpdateManyMutationInput, tournamentsUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentsWhereInput
  }

  /**
   * tournaments upsert
   */
  export type tournamentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * The filter to search for the tournaments to update in case it exists.
     */
    where: tournamentsWhereUniqueInput
    /**
     * In case the tournaments found by the `where` argument doesn't exist, create a new tournaments with this data.
     */
    create: XOR<tournamentsCreateInput, tournamentsUncheckedCreateInput>
    /**
     * In case the tournaments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentsUpdateInput, tournamentsUncheckedUpdateInput>
  }

  /**
   * tournaments delete
   */
  export type tournamentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    /**
     * Filter which tournaments to delete.
     */
    where: tournamentsWhereUniqueInput
  }

  /**
   * tournaments deleteMany
   */
  export type tournamentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to delete
     */
    where?: tournamentsWhereInput
  }

  /**
   * tournaments.games
   */
  export type tournaments$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    cursor?: gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * tournaments.tournament_participants
   */
  export type tournaments$tournament_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    cursor?: tournament_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * tournaments without action
   */
  export type tournamentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
  }


  /**
   * Model user_analytics
   */

  export type AggregateUser_analytics = {
    _count: User_analyticsCountAggregateOutputType | null
    _avg: User_analyticsAvgAggregateOutputType | null
    _sum: User_analyticsSumAggregateOutputType | null
    _min: User_analyticsMinAggregateOutputType | null
    _max: User_analyticsMaxAggregateOutputType | null
  }

  export type User_analyticsAvgAggregateOutputType = {
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
  }

  export type User_analyticsSumAggregateOutputType = {
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
  }

  export type User_analyticsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    date: Date | null
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
    createdAt: Date | null
  }

  export type User_analyticsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    date: Date | null
    games_played: number | null
    games_won: number | null
    analyses_completed: number | null
    time_played: number | null
    avg_equity: number | null
    elo_change: number | null
    createdAt: Date | null
  }

  export type User_analyticsCountAggregateOutputType = {
    id: number
    user_id: number
    date: number
    games_played: number
    games_won: number
    analyses_completed: number
    time_played: number
    avg_equity: number
    elo_change: number
    createdAt: number
    _all: number
  }


  export type User_analyticsAvgAggregateInputType = {
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
  }

  export type User_analyticsSumAggregateInputType = {
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
  }

  export type User_analyticsMinAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    createdAt?: true
  }

  export type User_analyticsMaxAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    createdAt?: true
  }

  export type User_analyticsCountAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    games_played?: true
    games_won?: true
    analyses_completed?: true
    time_played?: true
    avg_equity?: true
    elo_change?: true
    createdAt?: true
    _all?: true
  }

  export type User_analyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_analytics to aggregate.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_analytics
    **/
    _count?: true | User_analyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_analyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_analyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_analyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_analyticsMaxAggregateInputType
  }

  export type GetUser_analyticsAggregateType<T extends User_analyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_analytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_analytics[P]>
      : GetScalarType<T[P], AggregateUser_analytics[P]>
  }




  export type user_analyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_analyticsWhereInput
    orderBy?: user_analyticsOrderByWithAggregationInput | user_analyticsOrderByWithAggregationInput[]
    by: User_analyticsScalarFieldEnum[] | User_analyticsScalarFieldEnum
    having?: user_analyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_analyticsCountAggregateInputType | true
    _avg?: User_analyticsAvgAggregateInputType
    _sum?: User_analyticsSumAggregateInputType
    _min?: User_analyticsMinAggregateInputType
    _max?: User_analyticsMaxAggregateInputType
  }

  export type User_analyticsGroupByOutputType = {
    id: string
    user_id: string
    date: Date
    games_played: number
    games_won: number
    analyses_completed: number
    time_played: number
    avg_equity: number
    elo_change: number
    createdAt: Date
    _count: User_analyticsCountAggregateOutputType | null
    _avg: User_analyticsAvgAggregateOutputType | null
    _sum: User_analyticsSumAggregateOutputType | null
    _min: User_analyticsMinAggregateOutputType | null
    _max: User_analyticsMaxAggregateOutputType | null
  }

  type GetUser_analyticsGroupByPayload<T extends user_analyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_analyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_analyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_analyticsGroupByOutputType[P]>
            : GetScalarType<T[P], User_analyticsGroupByOutputType[P]>
        }
      >
    >


  export type user_analyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    games_played?: boolean
    games_won?: boolean
    analyses_completed?: boolean
    time_played?: boolean
    avg_equity?: boolean
    elo_change?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    games_played?: boolean
    games_won?: boolean
    analyses_completed?: boolean
    time_played?: boolean
    avg_equity?: boolean
    elo_change?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_analytics"]>

  export type user_analyticsSelectScalar = {
    id?: boolean
    user_id?: boolean
    date?: boolean
    games_played?: boolean
    games_won?: boolean
    analyses_completed?: boolean
    time_played?: boolean
    avg_equity?: boolean
    elo_change?: boolean
    createdAt?: boolean
  }

  export type user_analyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_analyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_analyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_analytics"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      date: Date
      games_played: number
      games_won: number
      analyses_completed: number
      time_played: number
      avg_equity: number
      elo_change: number
      createdAt: Date
    }, ExtArgs["result"]["user_analytics"]>
    composites: {}
  }

  type user_analyticsGetPayload<S extends boolean | null | undefined | user_analyticsDefaultArgs> = $Result.GetResult<Prisma.$user_analyticsPayload, S>

  type user_analyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_analyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_analyticsCountAggregateInputType | true
    }

  export interface user_analyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_analytics'], meta: { name: 'user_analytics' } }
    /**
     * Find zero or one User_analytics that matches the filter.
     * @param {user_analyticsFindUniqueArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_analyticsFindUniqueArgs>(args: SelectSubset<T, user_analyticsFindUniqueArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_analytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_analyticsFindUniqueOrThrowArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_analyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_analyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindFirstArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_analyticsFindFirstArgs>(args?: SelectSubset<T, user_analyticsFindFirstArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindFirstOrThrowArgs} args - Arguments to find a User_analytics
     * @example
     * // Get one User_analytics
     * const user_analytics = await prisma.user_analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_analyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_analyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_analytics
     * const user_analytics = await prisma.user_analytics.findMany()
     * 
     * // Get first 10 User_analytics
     * const user_analytics = await prisma.user_analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_analyticsWithIdOnly = await prisma.user_analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_analyticsFindManyArgs>(args?: SelectSubset<T, user_analyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_analytics.
     * @param {user_analyticsCreateArgs} args - Arguments to create a User_analytics.
     * @example
     * // Create one User_analytics
     * const User_analytics = await prisma.user_analytics.create({
     *   data: {
     *     // ... data to create a User_analytics
     *   }
     * })
     * 
     */
    create<T extends user_analyticsCreateArgs>(args: SelectSubset<T, user_analyticsCreateArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_analytics.
     * @param {user_analyticsCreateManyArgs} args - Arguments to create many User_analytics.
     * @example
     * // Create many User_analytics
     * const user_analytics = await prisma.user_analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_analyticsCreateManyArgs>(args?: SelectSubset<T, user_analyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_analytics and returns the data saved in the database.
     * @param {user_analyticsCreateManyAndReturnArgs} args - Arguments to create many User_analytics.
     * @example
     * // Create many User_analytics
     * const user_analytics = await prisma.user_analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_analytics and only return the `id`
     * const user_analyticsWithIdOnly = await prisma.user_analytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_analyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_analyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_analytics.
     * @param {user_analyticsDeleteArgs} args - Arguments to delete one User_analytics.
     * @example
     * // Delete one User_analytics
     * const User_analytics = await prisma.user_analytics.delete({
     *   where: {
     *     // ... filter to delete one User_analytics
     *   }
     * })
     * 
     */
    delete<T extends user_analyticsDeleteArgs>(args: SelectSubset<T, user_analyticsDeleteArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_analytics.
     * @param {user_analyticsUpdateArgs} args - Arguments to update one User_analytics.
     * @example
     * // Update one User_analytics
     * const user_analytics = await prisma.user_analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_analyticsUpdateArgs>(args: SelectSubset<T, user_analyticsUpdateArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_analytics.
     * @param {user_analyticsDeleteManyArgs} args - Arguments to filter User_analytics to delete.
     * @example
     * // Delete a few User_analytics
     * const { count } = await prisma.user_analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_analyticsDeleteManyArgs>(args?: SelectSubset<T, user_analyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_analytics
     * const user_analytics = await prisma.user_analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_analyticsUpdateManyArgs>(args: SelectSubset<T, user_analyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_analytics.
     * @param {user_analyticsUpsertArgs} args - Arguments to update or create a User_analytics.
     * @example
     * // Update or create a User_analytics
     * const user_analytics = await prisma.user_analytics.upsert({
     *   create: {
     *     // ... data to create a User_analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_analytics we want to update
     *   }
     * })
     */
    upsert<T extends user_analyticsUpsertArgs>(args: SelectSubset<T, user_analyticsUpsertArgs<ExtArgs>>): Prisma__user_analyticsClient<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsCountArgs} args - Arguments to filter User_analytics to count.
     * @example
     * // Count the number of User_analytics
     * const count = await prisma.user_analytics.count({
     *   where: {
     *     // ... the filter for the User_analytics we want to count
     *   }
     * })
    **/
    count<T extends user_analyticsCountArgs>(
      args?: Subset<T, user_analyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_analyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_analyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_analyticsAggregateArgs>(args: Subset<T, User_analyticsAggregateArgs>): Prisma.PrismaPromise<GetUser_analyticsAggregateType<T>>

    /**
     * Group by User_analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_analyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_analyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_analyticsGroupByArgs['orderBy'] }
        : { orderBy?: user_analyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_analyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_analyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_analytics model
   */
  readonly fields: user_analyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_analyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_analytics model
   */ 
  interface user_analyticsFieldRefs {
    readonly id: FieldRef<"user_analytics", 'String'>
    readonly user_id: FieldRef<"user_analytics", 'String'>
    readonly date: FieldRef<"user_analytics", 'DateTime'>
    readonly games_played: FieldRef<"user_analytics", 'Int'>
    readonly games_won: FieldRef<"user_analytics", 'Int'>
    readonly analyses_completed: FieldRef<"user_analytics", 'Int'>
    readonly time_played: FieldRef<"user_analytics", 'Int'>
    readonly avg_equity: FieldRef<"user_analytics", 'Float'>
    readonly elo_change: FieldRef<"user_analytics", 'Int'>
    readonly createdAt: FieldRef<"user_analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_analytics findUnique
   */
  export type user_analyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics findUniqueOrThrow
   */
  export type user_analyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics findFirst
   */
  export type user_analyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_analytics.
     */
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics findFirstOrThrow
   */
  export type user_analyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_analytics.
     */
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics findMany
   */
  export type user_analyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter, which user_analytics to fetch.
     */
    where?: user_analyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_analytics to fetch.
     */
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_analytics.
     */
    cursor?: user_analyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_analytics.
     */
    skip?: number
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * user_analytics create
   */
  export type user_analyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_analytics.
     */
    data: XOR<user_analyticsCreateInput, user_analyticsUncheckedCreateInput>
  }

  /**
   * user_analytics createMany
   */
  export type user_analyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_analytics.
     */
    data: user_analyticsCreateManyInput | user_analyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_analytics createManyAndReturn
   */
  export type user_analyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_analytics.
     */
    data: user_analyticsCreateManyInput | user_analyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_analytics update
   */
  export type user_analyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_analytics.
     */
    data: XOR<user_analyticsUpdateInput, user_analyticsUncheckedUpdateInput>
    /**
     * Choose, which user_analytics to update.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics updateMany
   */
  export type user_analyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_analytics.
     */
    data: XOR<user_analyticsUpdateManyMutationInput, user_analyticsUncheckedUpdateManyInput>
    /**
     * Filter which user_analytics to update
     */
    where?: user_analyticsWhereInput
  }

  /**
   * user_analytics upsert
   */
  export type user_analyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_analytics to update in case it exists.
     */
    where: user_analyticsWhereUniqueInput
    /**
     * In case the user_analytics found by the `where` argument doesn't exist, create a new user_analytics with this data.
     */
    create: XOR<user_analyticsCreateInput, user_analyticsUncheckedCreateInput>
    /**
     * In case the user_analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_analyticsUpdateInput, user_analyticsUncheckedUpdateInput>
  }

  /**
   * user_analytics delete
   */
  export type user_analyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    /**
     * Filter which user_analytics to delete.
     */
    where: user_analyticsWhereUniqueInput
  }

  /**
   * user_analytics deleteMany
   */
  export type user_analyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_analytics to delete
     */
    where?: user_analyticsWhereInput
  }

  /**
   * user_analytics without action
   */
  export type user_analyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    elo: number | null
  }

  export type UsersSumAggregateOutputType = {
    elo: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    avatar: string | null
    level: $Enums.Level | null
    elo: number | null
    subscriptionType: $Enums.SubscriptionType | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    avatar: string | null
    level: $Enums.Level | null
    elo: number | null
    subscriptionType: $Enums.SubscriptionType | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    avatar: number
    level: number
    elo: number
    subscriptionType: number
    isActive: number
    emailVerified: number
    createdAt: number
    lastLoginAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    elo?: true
  }

  export type UsersSumAggregateInputType = {
    elo?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    avatar?: true
    level?: true
    elo?: true
    subscriptionType?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    avatar?: true
    level?: true
    elo?: true
    subscriptionType?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    avatar?: true
    level?: true
    elo?: true
    subscriptionType?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password: string
    username: string
    avatar: string | null
    level: $Enums.Level
    elo: number
    subscriptionType: $Enums.SubscriptionType
    isActive: boolean
    emailVerified: boolean
    createdAt: Date
    lastLoginAt: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    level?: boolean
    elo?: boolean
    subscriptionType?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    analyses?: boolean | users$analysesArgs<ExtArgs>
    chat_messages?: boolean | users$chat_messagesArgs<ExtArgs>
    game_moves?: boolean | users$game_movesArgs<ExtArgs>
    games_games_black_player_idTousers?: boolean | users$games_games_black_player_idTousersArgs<ExtArgs>
    games_games_white_player_idTousers?: boolean | users$games_games_white_player_idTousersArgs<ExtArgs>
    subscriptions?: boolean | users$subscriptionsArgs<ExtArgs>
    tournament_participants?: boolean | users$tournament_participantsArgs<ExtArgs>
    tournaments?: boolean | users$tournamentsArgs<ExtArgs>
    user_analytics?: boolean | users$user_analyticsArgs<ExtArgs>
    websocket_connections?: boolean | users$websocket_connectionsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    level?: boolean
    elo?: boolean
    subscriptionType?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    avatar?: boolean
    level?: boolean
    elo?: boolean
    subscriptionType?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | users$analysesArgs<ExtArgs>
    chat_messages?: boolean | users$chat_messagesArgs<ExtArgs>
    game_moves?: boolean | users$game_movesArgs<ExtArgs>
    games_games_black_player_idTousers?: boolean | users$games_games_black_player_idTousersArgs<ExtArgs>
    games_games_white_player_idTousers?: boolean | users$games_games_white_player_idTousersArgs<ExtArgs>
    subscriptions?: boolean | users$subscriptionsArgs<ExtArgs>
    tournament_participants?: boolean | users$tournament_participantsArgs<ExtArgs>
    tournaments?: boolean | users$tournamentsArgs<ExtArgs>
    user_analytics?: boolean | users$user_analyticsArgs<ExtArgs>
    websocket_connections?: boolean | users$websocket_connectionsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      analyses: Prisma.$analysesPayload<ExtArgs>[]
      chat_messages: Prisma.$chat_messagesPayload<ExtArgs>[]
      game_moves: Prisma.$game_movesPayload<ExtArgs>[]
      games_games_black_player_idTousers: Prisma.$gamesPayload<ExtArgs>[]
      games_games_white_player_idTousers: Prisma.$gamesPayload<ExtArgs>[]
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs> | null
      tournament_participants: Prisma.$tournament_participantsPayload<ExtArgs>[]
      tournaments: Prisma.$tournamentsPayload<ExtArgs>[]
      user_analytics: Prisma.$user_analyticsPayload<ExtArgs>[]
      websocket_connections: Prisma.$websocket_connectionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      username: string
      avatar: string | null
      level: $Enums.Level
      elo: number
      subscriptionType: $Enums.SubscriptionType
      isActive: boolean
      emailVerified: boolean
      createdAt: Date
      lastLoginAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analyses<T extends users$analysesArgs<ExtArgs> = {}>(args?: Subset<T, users$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analysesPayload<ExtArgs>, T, "findMany"> | Null>
    chat_messages<T extends users$chat_messagesArgs<ExtArgs> = {}>(args?: Subset<T, users$chat_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany"> | Null>
    game_moves<T extends users$game_movesArgs<ExtArgs> = {}>(args?: Subset<T, users$game_movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_movesPayload<ExtArgs>, T, "findMany"> | Null>
    games_games_black_player_idTousers<T extends users$games_games_black_player_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$games_games_black_player_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany"> | Null>
    games_games_white_player_idTousers<T extends users$games_games_white_player_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$games_games_white_player_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends users$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, users$subscriptionsArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tournament_participants<T extends users$tournament_participantsArgs<ExtArgs> = {}>(args?: Subset<T, users$tournament_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournament_participantsPayload<ExtArgs>, T, "findMany"> | Null>
    tournaments<T extends users$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, users$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentsPayload<ExtArgs>, T, "findMany"> | Null>
    user_analytics<T extends users$user_analyticsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_analyticsPayload<ExtArgs>, T, "findMany"> | Null>
    websocket_connections<T extends users$websocket_connectionsArgs<ExtArgs> = {}>(args?: Subset<T, users$websocket_connectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly avatar: FieldRef<"users", 'String'>
    readonly level: FieldRef<"users", 'Level'>
    readonly elo: FieldRef<"users", 'Int'>
    readonly subscriptionType: FieldRef<"users", 'SubscriptionType'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly emailVerified: FieldRef<"users", 'Boolean'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly lastLoginAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.analyses
   */
  export type users$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analyses
     */
    select?: analysesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analysesInclude<ExtArgs> | null
    where?: analysesWhereInput
    orderBy?: analysesOrderByWithRelationInput | analysesOrderByWithRelationInput[]
    cursor?: analysesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysesScalarFieldEnum | AnalysesScalarFieldEnum[]
  }

  /**
   * users.chat_messages
   */
  export type users$chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * users.game_moves
   */
  export type users$game_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_moves
     */
    select?: game_movesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_movesInclude<ExtArgs> | null
    where?: game_movesWhereInput
    orderBy?: game_movesOrderByWithRelationInput | game_movesOrderByWithRelationInput[]
    cursor?: game_movesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Game_movesScalarFieldEnum | Game_movesScalarFieldEnum[]
  }

  /**
   * users.games_games_black_player_idTousers
   */
  export type users$games_games_black_player_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    cursor?: gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * users.games_games_white_player_idTousers
   */
  export type users$games_games_white_player_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
    orderBy?: gamesOrderByWithRelationInput | gamesOrderByWithRelationInput[]
    cursor?: gamesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesScalarFieldEnum | GamesScalarFieldEnum[]
  }

  /**
   * users.subscriptions
   */
  export type users$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    where?: subscriptionsWhereInput
  }

  /**
   * users.tournament_participants
   */
  export type users$tournament_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament_participants
     */
    select?: tournament_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournament_participantsInclude<ExtArgs> | null
    where?: tournament_participantsWhereInput
    orderBy?: tournament_participantsOrderByWithRelationInput | tournament_participantsOrderByWithRelationInput[]
    cursor?: tournament_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tournament_participantsScalarFieldEnum | Tournament_participantsScalarFieldEnum[]
  }

  /**
   * users.tournaments
   */
  export type users$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournaments
     */
    select?: tournamentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentsInclude<ExtArgs> | null
    where?: tournamentsWhereInput
    orderBy?: tournamentsOrderByWithRelationInput | tournamentsOrderByWithRelationInput[]
    cursor?: tournamentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentsScalarFieldEnum | TournamentsScalarFieldEnum[]
  }

  /**
   * users.user_analytics
   */
  export type users$user_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_analytics
     */
    select?: user_analyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_analyticsInclude<ExtArgs> | null
    where?: user_analyticsWhereInput
    orderBy?: user_analyticsOrderByWithRelationInput | user_analyticsOrderByWithRelationInput[]
    cursor?: user_analyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_analyticsScalarFieldEnum | User_analyticsScalarFieldEnum[]
  }

  /**
   * users.websocket_connections
   */
  export type users$websocket_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    where?: websocket_connectionsWhereInput
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    cursor?: websocket_connectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model websocket_connections
   */

  export type AggregateWebsocket_connections = {
    _count: Websocket_connectionsCountAggregateOutputType | null
    _min: Websocket_connectionsMinAggregateOutputType | null
    _max: Websocket_connectionsMaxAggregateOutputType | null
  }

  export type Websocket_connectionsMinAggregateOutputType = {
    id: string | null
    connection_id: string | null
    user_id: string | null
    game_id: string | null
    connected_at: Date | null
    last_ping: Date | null
    is_active: boolean | null
  }

  export type Websocket_connectionsMaxAggregateOutputType = {
    id: string | null
    connection_id: string | null
    user_id: string | null
    game_id: string | null
    connected_at: Date | null
    last_ping: Date | null
    is_active: boolean | null
  }

  export type Websocket_connectionsCountAggregateOutputType = {
    id: number
    connection_id: number
    user_id: number
    game_id: number
    connected_at: number
    last_ping: number
    is_active: number
    _all: number
  }


  export type Websocket_connectionsMinAggregateInputType = {
    id?: true
    connection_id?: true
    user_id?: true
    game_id?: true
    connected_at?: true
    last_ping?: true
    is_active?: true
  }

  export type Websocket_connectionsMaxAggregateInputType = {
    id?: true
    connection_id?: true
    user_id?: true
    game_id?: true
    connected_at?: true
    last_ping?: true
    is_active?: true
  }

  export type Websocket_connectionsCountAggregateInputType = {
    id?: true
    connection_id?: true
    user_id?: true
    game_id?: true
    connected_at?: true
    last_ping?: true
    is_active?: true
    _all?: true
  }

  export type Websocket_connectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which websocket_connections to aggregate.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned websocket_connections
    **/
    _count?: true | Websocket_connectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Websocket_connectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Websocket_connectionsMaxAggregateInputType
  }

  export type GetWebsocket_connectionsAggregateType<T extends Websocket_connectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsocket_connections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsocket_connections[P]>
      : GetScalarType<T[P], AggregateWebsocket_connections[P]>
  }




  export type websocket_connectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: websocket_connectionsWhereInput
    orderBy?: websocket_connectionsOrderByWithAggregationInput | websocket_connectionsOrderByWithAggregationInput[]
    by: Websocket_connectionsScalarFieldEnum[] | Websocket_connectionsScalarFieldEnum
    having?: websocket_connectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Websocket_connectionsCountAggregateInputType | true
    _min?: Websocket_connectionsMinAggregateInputType
    _max?: Websocket_connectionsMaxAggregateInputType
  }

  export type Websocket_connectionsGroupByOutputType = {
    id: string
    connection_id: string
    user_id: string
    game_id: string | null
    connected_at: Date
    last_ping: Date
    is_active: boolean
    _count: Websocket_connectionsCountAggregateOutputType | null
    _min: Websocket_connectionsMinAggregateOutputType | null
    _max: Websocket_connectionsMaxAggregateOutputType | null
  }

  type GetWebsocket_connectionsGroupByPayload<T extends websocket_connectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Websocket_connectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Websocket_connectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Websocket_connectionsGroupByOutputType[P]>
            : GetScalarType<T[P], Websocket_connectionsGroupByOutputType[P]>
        }
      >
    >


  export type websocket_connectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connection_id?: boolean
    user_id?: boolean
    game_id?: boolean
    connected_at?: boolean
    last_ping?: boolean
    is_active?: boolean
    games?: boolean | websocket_connections$gamesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websocket_connections"]>

  export type websocket_connectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connection_id?: boolean
    user_id?: boolean
    game_id?: boolean
    connected_at?: boolean
    last_ping?: boolean
    is_active?: boolean
    games?: boolean | websocket_connections$gamesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websocket_connections"]>

  export type websocket_connectionsSelectScalar = {
    id?: boolean
    connection_id?: boolean
    user_id?: boolean
    game_id?: boolean
    connected_at?: boolean
    last_ping?: boolean
    is_active?: boolean
  }

  export type websocket_connectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | websocket_connections$gamesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type websocket_connectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | websocket_connections$gamesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $websocket_connectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "websocket_connections"
    objects: {
      games: Prisma.$gamesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connection_id: string
      user_id: string
      game_id: string | null
      connected_at: Date
      last_ping: Date
      is_active: boolean
    }, ExtArgs["result"]["websocket_connections"]>
    composites: {}
  }

  type websocket_connectionsGetPayload<S extends boolean | null | undefined | websocket_connectionsDefaultArgs> = $Result.GetResult<Prisma.$websocket_connectionsPayload, S>

  type websocket_connectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<websocket_connectionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Websocket_connectionsCountAggregateInputType | true
    }

  export interface websocket_connectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['websocket_connections'], meta: { name: 'websocket_connections' } }
    /**
     * Find zero or one Websocket_connections that matches the filter.
     * @param {websocket_connectionsFindUniqueArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends websocket_connectionsFindUniqueArgs>(args: SelectSubset<T, websocket_connectionsFindUniqueArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Websocket_connections that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {websocket_connectionsFindUniqueOrThrowArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends websocket_connectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, websocket_connectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Websocket_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsFindFirstArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends websocket_connectionsFindFirstArgs>(args?: SelectSubset<T, websocket_connectionsFindFirstArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Websocket_connections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsFindFirstOrThrowArgs} args - Arguments to find a Websocket_connections
     * @example
     * // Get one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends websocket_connectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, websocket_connectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Websocket_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findMany()
     * 
     * // Get first 10 Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websocket_connectionsWithIdOnly = await prisma.websocket_connections.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends websocket_connectionsFindManyArgs>(args?: SelectSubset<T, websocket_connectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Websocket_connections.
     * @param {websocket_connectionsCreateArgs} args - Arguments to create a Websocket_connections.
     * @example
     * // Create one Websocket_connections
     * const Websocket_connections = await prisma.websocket_connections.create({
     *   data: {
     *     // ... data to create a Websocket_connections
     *   }
     * })
     * 
     */
    create<T extends websocket_connectionsCreateArgs>(args: SelectSubset<T, websocket_connectionsCreateArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Websocket_connections.
     * @param {websocket_connectionsCreateManyArgs} args - Arguments to create many Websocket_connections.
     * @example
     * // Create many Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends websocket_connectionsCreateManyArgs>(args?: SelectSubset<T, websocket_connectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Websocket_connections and returns the data saved in the database.
     * @param {websocket_connectionsCreateManyAndReturnArgs} args - Arguments to create many Websocket_connections.
     * @example
     * // Create many Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Websocket_connections and only return the `id`
     * const websocket_connectionsWithIdOnly = await prisma.websocket_connections.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends websocket_connectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, websocket_connectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Websocket_connections.
     * @param {websocket_connectionsDeleteArgs} args - Arguments to delete one Websocket_connections.
     * @example
     * // Delete one Websocket_connections
     * const Websocket_connections = await prisma.websocket_connections.delete({
     *   where: {
     *     // ... filter to delete one Websocket_connections
     *   }
     * })
     * 
     */
    delete<T extends websocket_connectionsDeleteArgs>(args: SelectSubset<T, websocket_connectionsDeleteArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Websocket_connections.
     * @param {websocket_connectionsUpdateArgs} args - Arguments to update one Websocket_connections.
     * @example
     * // Update one Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends websocket_connectionsUpdateArgs>(args: SelectSubset<T, websocket_connectionsUpdateArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Websocket_connections.
     * @param {websocket_connectionsDeleteManyArgs} args - Arguments to filter Websocket_connections to delete.
     * @example
     * // Delete a few Websocket_connections
     * const { count } = await prisma.websocket_connections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends websocket_connectionsDeleteManyArgs>(args?: SelectSubset<T, websocket_connectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends websocket_connectionsUpdateManyArgs>(args: SelectSubset<T, websocket_connectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Websocket_connections.
     * @param {websocket_connectionsUpsertArgs} args - Arguments to update or create a Websocket_connections.
     * @example
     * // Update or create a Websocket_connections
     * const websocket_connections = await prisma.websocket_connections.upsert({
     *   create: {
     *     // ... data to create a Websocket_connections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Websocket_connections we want to update
     *   }
     * })
     */
    upsert<T extends websocket_connectionsUpsertArgs>(args: SelectSubset<T, websocket_connectionsUpsertArgs<ExtArgs>>): Prisma__websocket_connectionsClient<$Result.GetResult<Prisma.$websocket_connectionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsCountArgs} args - Arguments to filter Websocket_connections to count.
     * @example
     * // Count the number of Websocket_connections
     * const count = await prisma.websocket_connections.count({
     *   where: {
     *     // ... the filter for the Websocket_connections we want to count
     *   }
     * })
    **/
    count<T extends websocket_connectionsCountArgs>(
      args?: Subset<T, websocket_connectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Websocket_connectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Websocket_connectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Websocket_connectionsAggregateArgs>(args: Subset<T, Websocket_connectionsAggregateArgs>): Prisma.PrismaPromise<GetWebsocket_connectionsAggregateType<T>>

    /**
     * Group by Websocket_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {websocket_connectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends websocket_connectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: websocket_connectionsGroupByArgs['orderBy'] }
        : { orderBy?: websocket_connectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, websocket_connectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsocket_connectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the websocket_connections model
   */
  readonly fields: websocket_connectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for websocket_connections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__websocket_connectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends websocket_connections$gamesArgs<ExtArgs> = {}>(args?: Subset<T, websocket_connections$gamesArgs<ExtArgs>>): Prisma__gamesClient<$Result.GetResult<Prisma.$gamesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the websocket_connections model
   */ 
  interface websocket_connectionsFieldRefs {
    readonly id: FieldRef<"websocket_connections", 'String'>
    readonly connection_id: FieldRef<"websocket_connections", 'String'>
    readonly user_id: FieldRef<"websocket_connections", 'String'>
    readonly game_id: FieldRef<"websocket_connections", 'String'>
    readonly connected_at: FieldRef<"websocket_connections", 'DateTime'>
    readonly last_ping: FieldRef<"websocket_connections", 'DateTime'>
    readonly is_active: FieldRef<"websocket_connections", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * websocket_connections findUnique
   */
  export type websocket_connectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections findUniqueOrThrow
   */
  export type websocket_connectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections findFirst
   */
  export type websocket_connectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for websocket_connections.
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of websocket_connections.
     */
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * websocket_connections findFirstOrThrow
   */
  export type websocket_connectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for websocket_connections.
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of websocket_connections.
     */
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * websocket_connections findMany
   */
  export type websocket_connectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which websocket_connections to fetch.
     */
    where?: websocket_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of websocket_connections to fetch.
     */
    orderBy?: websocket_connectionsOrderByWithRelationInput | websocket_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing websocket_connections.
     */
    cursor?: websocket_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` websocket_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` websocket_connections.
     */
    skip?: number
    distinct?: Websocket_connectionsScalarFieldEnum | Websocket_connectionsScalarFieldEnum[]
  }

  /**
   * websocket_connections create
   */
  export type websocket_connectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a websocket_connections.
     */
    data: XOR<websocket_connectionsCreateInput, websocket_connectionsUncheckedCreateInput>
  }

  /**
   * websocket_connections createMany
   */
  export type websocket_connectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many websocket_connections.
     */
    data: websocket_connectionsCreateManyInput | websocket_connectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * websocket_connections createManyAndReturn
   */
  export type websocket_connectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many websocket_connections.
     */
    data: websocket_connectionsCreateManyInput | websocket_connectionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * websocket_connections update
   */
  export type websocket_connectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a websocket_connections.
     */
    data: XOR<websocket_connectionsUpdateInput, websocket_connectionsUncheckedUpdateInput>
    /**
     * Choose, which websocket_connections to update.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections updateMany
   */
  export type websocket_connectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update websocket_connections.
     */
    data: XOR<websocket_connectionsUpdateManyMutationInput, websocket_connectionsUncheckedUpdateManyInput>
    /**
     * Filter which websocket_connections to update
     */
    where?: websocket_connectionsWhereInput
  }

  /**
   * websocket_connections upsert
   */
  export type websocket_connectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the websocket_connections to update in case it exists.
     */
    where: websocket_connectionsWhereUniqueInput
    /**
     * In case the websocket_connections found by the `where` argument doesn't exist, create a new websocket_connections with this data.
     */
    create: XOR<websocket_connectionsCreateInput, websocket_connectionsUncheckedCreateInput>
    /**
     * In case the websocket_connections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<websocket_connectionsUpdateInput, websocket_connectionsUncheckedUpdateInput>
  }

  /**
   * websocket_connections delete
   */
  export type websocket_connectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
    /**
     * Filter which websocket_connections to delete.
     */
    where: websocket_connectionsWhereUniqueInput
  }

  /**
   * websocket_connections deleteMany
   */
  export type websocket_connectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which websocket_connections to delete
     */
    where?: websocket_connectionsWhereInput
  }

  /**
   * websocket_connections.games
   */
  export type websocket_connections$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the games
     */
    select?: gamesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesInclude<ExtArgs> | null
    where?: gamesWhereInput
  }

  /**
   * websocket_connections without action
   */
  export type websocket_connectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the websocket_connections
     */
    select?: websocket_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: websocket_connectionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnalysesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    board_state: 'board_state',
    dice: 'dice',
    move: 'move',
    best_move: 'best_move',
    equity: 'equity',
    pr: 'pr',
    explanation: 'explanation',
    alternatives: 'alternatives',
    analysis_type: 'analysis_type',
    createdAt: 'createdAt'
  };

  export type AnalysesScalarFieldEnum = (typeof AnalysesScalarFieldEnum)[keyof typeof AnalysesScalarFieldEnum]


  export const Chat_messagesScalarFieldEnum: {
    id: 'id',
    game_id: 'game_id',
    user_id: 'user_id',
    message: 'message',
    message_type: 'message_type',
    createdAt: 'createdAt'
  };

  export type Chat_messagesScalarFieldEnum = (typeof Chat_messagesScalarFieldEnum)[keyof typeof Chat_messagesScalarFieldEnum]


  export const Game_movesScalarFieldEnum: {
    id: 'id',
    game_id: 'game_id',
    user_id: 'user_id',
    player: 'player',
    dice: 'dice',
    move: 'move',
    from_point: 'from_point',
    to_point: 'to_point',
    equity: 'equity',
    pr: 'pr',
    thinking_time: 'thinking_time',
    createdAt: 'createdAt'
  };

  export type Game_movesScalarFieldEnum = (typeof Game_movesScalarFieldEnum)[keyof typeof Game_movesScalarFieldEnum]


  export const GamesScalarFieldEnum: {
    id: 'id',
    white_player_id: 'white_player_id',
    black_player_id: 'black_player_id',
    status: 'status',
    board_state: 'board_state',
    gameMode: 'gameMode',
    current_player: 'current_player',
    dice: 'dice',
    white_score: 'white_score',
    black_score: 'black_score',
    createdAt: 'createdAt',
    finished_at: 'finished_at',
    winner: 'winner',
    tournament_id: 'tournament_id'
  };

  export type GamesScalarFieldEnum = (typeof GamesScalarFieldEnum)[keyof typeof GamesScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    stripe_subscription_id: 'stripe_subscription_id',
    stripe_customer_id: 'stripe_customer_id',
    plan: 'plan',
    status: 'status',
    current_period_start: 'current_period_start',
    current_period_end: 'current_period_end',
    cancel_at_period_end: 'cancel_at_period_end',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const Tournament_participantsScalarFieldEnum: {
    id: 'id',
    tournament_id: 'tournament_id',
    user_id: 'user_id',
    registered_at: 'registered_at',
    current_position: 'current_position',
    eliminated_at: 'eliminated_at'
  };

  export type Tournament_participantsScalarFieldEnum = (typeof Tournament_participantsScalarFieldEnum)[keyof typeof Tournament_participantsScalarFieldEnum]


  export const TournamentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    entryFee: 'entryFee',
    prizePool: 'prizePool',
    maxPlayers: 'maxPlayers',
    status: 'status',
    start_time: 'start_time',
    end_time: 'end_time',
    created_by: 'created_by',
    createdAt: 'createdAt'
  };

  export type TournamentsScalarFieldEnum = (typeof TournamentsScalarFieldEnum)[keyof typeof TournamentsScalarFieldEnum]


  export const User_analyticsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    date: 'date',
    games_played: 'games_played',
    games_won: 'games_won',
    analyses_completed: 'analyses_completed',
    time_played: 'time_played',
    avg_equity: 'avg_equity',
    elo_change: 'elo_change',
    createdAt: 'createdAt'
  };

  export type User_analyticsScalarFieldEnum = (typeof User_analyticsScalarFieldEnum)[keyof typeof User_analyticsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    avatar: 'avatar',
    level: 'level',
    elo: 'elo',
    subscriptionType: 'subscriptionType',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Websocket_connectionsScalarFieldEnum: {
    id: 'id',
    connection_id: 'connection_id',
    user_id: 'user_id',
    game_id: 'game_id',
    connected_at: 'connected_at',
    last_ping: 'last_ping',
    is_active: 'is_active'
  };

  export type Websocket_connectionsScalarFieldEnum = (typeof Websocket_connectionsScalarFieldEnum)[keyof typeof Websocket_connectionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AnalysisType'
   */
  export type EnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType'>
    


  /**
   * Reference to a field of type 'AnalysisType[]'
   */
  export type ListEnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'Player'
   */
  export type EnumPlayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Player'>
    


  /**
   * Reference to a field of type 'Player[]'
   */
  export type ListEnumPlayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Player[]'>
    


  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus'>
    


  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus[]'>
    


  /**
   * Reference to a field of type 'GameMode'
   */
  export type EnumGameModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameMode'>
    


  /**
   * Reference to a field of type 'GameMode[]'
   */
  export type ListEnumGameModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameMode[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TournamentStatus'
   */
  export type EnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus'>
    


  /**
   * Reference to a field of type 'TournamentStatus[]'
   */
  export type ListEnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus[]'>
    


  /**
   * Reference to a field of type 'Level'
   */
  export type EnumLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Level'>
    


  /**
   * Reference to a field of type 'Level[]'
   */
  export type ListEnumLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Level[]'>
    


  /**
   * Reference to a field of type 'SubscriptionType'
   */
  export type EnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType'>
    


  /**
   * Reference to a field of type 'SubscriptionType[]'
   */
  export type ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType[]'>
    
  /**
   * Deep Input Types
   */


  export type analysesWhereInput = {
    AND?: analysesWhereInput | analysesWhereInput[]
    OR?: analysesWhereInput[]
    NOT?: analysesWhereInput | analysesWhereInput[]
    id?: StringFilter<"analyses"> | string
    user_id?: StringFilter<"analyses"> | string
    board_state?: StringFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringFilter<"analyses"> | string
    best_move?: StringFilter<"analyses"> | string
    equity?: FloatFilter<"analyses"> | number
    pr?: FloatFilter<"analyses"> | number
    explanation?: StringFilter<"analyses"> | string
    alternatives?: JsonFilter<"analyses">
    analysis_type?: EnumAnalysisTypeFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeFilter<"analyses"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type analysesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    board_state?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    best_move?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    alternatives?: SortOrder
    analysis_type?: SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type analysesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: analysesWhereInput | analysesWhereInput[]
    OR?: analysesWhereInput[]
    NOT?: analysesWhereInput | analysesWhereInput[]
    user_id?: StringFilter<"analyses"> | string
    board_state?: StringFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringFilter<"analyses"> | string
    best_move?: StringFilter<"analyses"> | string
    equity?: FloatFilter<"analyses"> | number
    pr?: FloatFilter<"analyses"> | number
    explanation?: StringFilter<"analyses"> | string
    alternatives?: JsonFilter<"analyses">
    analysis_type?: EnumAnalysisTypeFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeFilter<"analyses"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type analysesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    board_state?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    best_move?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    alternatives?: SortOrder
    analysis_type?: SortOrder
    createdAt?: SortOrder
    _count?: analysesCountOrderByAggregateInput
    _avg?: analysesAvgOrderByAggregateInput
    _max?: analysesMaxOrderByAggregateInput
    _min?: analysesMinOrderByAggregateInput
    _sum?: analysesSumOrderByAggregateInput
  }

  export type analysesScalarWhereWithAggregatesInput = {
    AND?: analysesScalarWhereWithAggregatesInput | analysesScalarWhereWithAggregatesInput[]
    OR?: analysesScalarWhereWithAggregatesInput[]
    NOT?: analysesScalarWhereWithAggregatesInput | analysesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"analyses"> | string
    user_id?: StringWithAggregatesFilter<"analyses"> | string
    board_state?: StringWithAggregatesFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringWithAggregatesFilter<"analyses"> | string
    best_move?: StringWithAggregatesFilter<"analyses"> | string
    equity?: FloatWithAggregatesFilter<"analyses"> | number
    pr?: FloatWithAggregatesFilter<"analyses"> | number
    explanation?: StringWithAggregatesFilter<"analyses"> | string
    alternatives?: JsonWithAggregatesFilter<"analyses">
    analysis_type?: EnumAnalysisTypeWithAggregatesFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeWithAggregatesFilter<"analyses"> | Date | string
  }

  export type chat_messagesWhereInput = {
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    id?: StringFilter<"chat_messages"> | string
    game_id?: StringFilter<"chat_messages"> | string
    user_id?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringFilter<"chat_messages"> | string
    message_type?: EnumMessageTypeFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"chat_messages"> | Date | string
    games?: XOR<GamesRelationFilter, gamesWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type chat_messagesOrderByWithRelationInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    message?: SortOrder
    message_type?: SortOrder
    createdAt?: SortOrder
    games?: gamesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type chat_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    game_id?: StringFilter<"chat_messages"> | string
    user_id?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringFilter<"chat_messages"> | string
    message_type?: EnumMessageTypeFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"chat_messages"> | Date | string
    games?: XOR<GamesRelationFilter, gamesWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type chat_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    message?: SortOrder
    message_type?: SortOrder
    createdAt?: SortOrder
    _count?: chat_messagesCountOrderByAggregateInput
    _max?: chat_messagesMaxOrderByAggregateInput
    _min?: chat_messagesMinOrderByAggregateInput
  }

  export type chat_messagesScalarWhereWithAggregatesInput = {
    AND?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    OR?: chat_messagesScalarWhereWithAggregatesInput[]
    NOT?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chat_messages"> | string
    game_id?: StringWithAggregatesFilter<"chat_messages"> | string
    user_id?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    message?: StringWithAggregatesFilter<"chat_messages"> | string
    message_type?: EnumMessageTypeWithAggregatesFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeWithAggregatesFilter<"chat_messages"> | Date | string
  }

  export type game_movesWhereInput = {
    AND?: game_movesWhereInput | game_movesWhereInput[]
    OR?: game_movesWhereInput[]
    NOT?: game_movesWhereInput | game_movesWhereInput[]
    id?: StringFilter<"game_moves"> | string
    game_id?: StringFilter<"game_moves"> | string
    user_id?: StringNullableFilter<"game_moves"> | string | null
    player?: EnumPlayerFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringFilter<"game_moves"> | string
    from_point?: IntNullableFilter<"game_moves"> | number | null
    to_point?: IntNullableFilter<"game_moves"> | number | null
    equity?: FloatNullableFilter<"game_moves"> | number | null
    pr?: FloatNullableFilter<"game_moves"> | number | null
    thinking_time?: IntNullableFilter<"game_moves"> | number | null
    createdAt?: DateTimeFilter<"game_moves"> | Date | string
    games?: XOR<GamesRelationFilter, gamesWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type game_movesOrderByWithRelationInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    player?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    from_point?: SortOrderInput | SortOrder
    to_point?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    pr?: SortOrderInput | SortOrder
    thinking_time?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    games?: gamesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type game_movesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: game_movesWhereInput | game_movesWhereInput[]
    OR?: game_movesWhereInput[]
    NOT?: game_movesWhereInput | game_movesWhereInput[]
    game_id?: StringFilter<"game_moves"> | string
    user_id?: StringNullableFilter<"game_moves"> | string | null
    player?: EnumPlayerFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringFilter<"game_moves"> | string
    from_point?: IntNullableFilter<"game_moves"> | number | null
    to_point?: IntNullableFilter<"game_moves"> | number | null
    equity?: FloatNullableFilter<"game_moves"> | number | null
    pr?: FloatNullableFilter<"game_moves"> | number | null
    thinking_time?: IntNullableFilter<"game_moves"> | number | null
    createdAt?: DateTimeFilter<"game_moves"> | Date | string
    games?: XOR<GamesRelationFilter, gamesWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type game_movesOrderByWithAggregationInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    player?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    from_point?: SortOrderInput | SortOrder
    to_point?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    pr?: SortOrderInput | SortOrder
    thinking_time?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: game_movesCountOrderByAggregateInput
    _avg?: game_movesAvgOrderByAggregateInput
    _max?: game_movesMaxOrderByAggregateInput
    _min?: game_movesMinOrderByAggregateInput
    _sum?: game_movesSumOrderByAggregateInput
  }

  export type game_movesScalarWhereWithAggregatesInput = {
    AND?: game_movesScalarWhereWithAggregatesInput | game_movesScalarWhereWithAggregatesInput[]
    OR?: game_movesScalarWhereWithAggregatesInput[]
    NOT?: game_movesScalarWhereWithAggregatesInput | game_movesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"game_moves"> | string
    game_id?: StringWithAggregatesFilter<"game_moves"> | string
    user_id?: StringNullableWithAggregatesFilter<"game_moves"> | string | null
    player?: EnumPlayerWithAggregatesFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringWithAggregatesFilter<"game_moves"> | string
    from_point?: IntNullableWithAggregatesFilter<"game_moves"> | number | null
    to_point?: IntNullableWithAggregatesFilter<"game_moves"> | number | null
    equity?: FloatNullableWithAggregatesFilter<"game_moves"> | number | null
    pr?: FloatNullableWithAggregatesFilter<"game_moves"> | number | null
    thinking_time?: IntNullableWithAggregatesFilter<"game_moves"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"game_moves"> | Date | string
  }

  export type gamesWhereInput = {
    AND?: gamesWhereInput | gamesWhereInput[]
    OR?: gamesWhereInput[]
    NOT?: gamesWhereInput | gamesWhereInput[]
    id?: StringFilter<"games"> | string
    white_player_id?: StringNullableFilter<"games"> | string | null
    black_player_id?: StringNullableFilter<"games"> | string | null
    status?: EnumGameStatusFilter<"games"> | $Enums.GameStatus
    board_state?: StringFilter<"games"> | string
    gameMode?: EnumGameModeFilter<"games"> | $Enums.GameMode
    current_player?: EnumPlayerFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    white_score?: IntFilter<"games"> | number
    black_score?: IntFilter<"games"> | number
    createdAt?: DateTimeFilter<"games"> | Date | string
    finished_at?: DateTimeNullableFilter<"games"> | Date | string | null
    winner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    tournament_id?: StringNullableFilter<"games"> | string | null
    chat_messages?: Chat_messagesListRelationFilter
    game_moves?: Game_movesListRelationFilter
    users_games_black_player_idTousers?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    tournaments?: XOR<TournamentsNullableRelationFilter, tournamentsWhereInput> | null
    users_games_white_player_idTousers?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    websocket_connections?: Websocket_connectionsListRelationFilter
  }

  export type gamesOrderByWithRelationInput = {
    id?: SortOrder
    white_player_id?: SortOrderInput | SortOrder
    black_player_id?: SortOrderInput | SortOrder
    status?: SortOrder
    board_state?: SortOrder
    gameMode?: SortOrder
    current_player?: SortOrder
    dice?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
    createdAt?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    winner?: SortOrderInput | SortOrder
    tournament_id?: SortOrderInput | SortOrder
    chat_messages?: chat_messagesOrderByRelationAggregateInput
    game_moves?: game_movesOrderByRelationAggregateInput
    users_games_black_player_idTousers?: usersOrderByWithRelationInput
    tournaments?: tournamentsOrderByWithRelationInput
    users_games_white_player_idTousers?: usersOrderByWithRelationInput
    websocket_connections?: websocket_connectionsOrderByRelationAggregateInput
  }

  export type gamesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: gamesWhereInput | gamesWhereInput[]
    OR?: gamesWhereInput[]
    NOT?: gamesWhereInput | gamesWhereInput[]
    white_player_id?: StringNullableFilter<"games"> | string | null
    black_player_id?: StringNullableFilter<"games"> | string | null
    status?: EnumGameStatusFilter<"games"> | $Enums.GameStatus
    board_state?: StringFilter<"games"> | string
    gameMode?: EnumGameModeFilter<"games"> | $Enums.GameMode
    current_player?: EnumPlayerFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    white_score?: IntFilter<"games"> | number
    black_score?: IntFilter<"games"> | number
    createdAt?: DateTimeFilter<"games"> | Date | string
    finished_at?: DateTimeNullableFilter<"games"> | Date | string | null
    winner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    tournament_id?: StringNullableFilter<"games"> | string | null
    chat_messages?: Chat_messagesListRelationFilter
    game_moves?: Game_movesListRelationFilter
    users_games_black_player_idTousers?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    tournaments?: XOR<TournamentsNullableRelationFilter, tournamentsWhereInput> | null
    users_games_white_player_idTousers?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    websocket_connections?: Websocket_connectionsListRelationFilter
  }, "id">

  export type gamesOrderByWithAggregationInput = {
    id?: SortOrder
    white_player_id?: SortOrderInput | SortOrder
    black_player_id?: SortOrderInput | SortOrder
    status?: SortOrder
    board_state?: SortOrder
    gameMode?: SortOrder
    current_player?: SortOrder
    dice?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
    createdAt?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    winner?: SortOrderInput | SortOrder
    tournament_id?: SortOrderInput | SortOrder
    _count?: gamesCountOrderByAggregateInput
    _avg?: gamesAvgOrderByAggregateInput
    _max?: gamesMaxOrderByAggregateInput
    _min?: gamesMinOrderByAggregateInput
    _sum?: gamesSumOrderByAggregateInput
  }

  export type gamesScalarWhereWithAggregatesInput = {
    AND?: gamesScalarWhereWithAggregatesInput | gamesScalarWhereWithAggregatesInput[]
    OR?: gamesScalarWhereWithAggregatesInput[]
    NOT?: gamesScalarWhereWithAggregatesInput | gamesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"games"> | string
    white_player_id?: StringNullableWithAggregatesFilter<"games"> | string | null
    black_player_id?: StringNullableWithAggregatesFilter<"games"> | string | null
    status?: EnumGameStatusWithAggregatesFilter<"games"> | $Enums.GameStatus
    board_state?: StringWithAggregatesFilter<"games"> | string
    gameMode?: EnumGameModeWithAggregatesFilter<"games"> | $Enums.GameMode
    current_player?: EnumPlayerWithAggregatesFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    white_score?: IntWithAggregatesFilter<"games"> | number
    black_score?: IntWithAggregatesFilter<"games"> | number
    createdAt?: DateTimeWithAggregatesFilter<"games"> | Date | string
    finished_at?: DateTimeNullableWithAggregatesFilter<"games"> | Date | string | null
    winner?: EnumPlayerNullableWithAggregatesFilter<"games"> | $Enums.Player | null
    tournament_id?: StringNullableWithAggregatesFilter<"games"> | string | null
  }

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    id?: StringFilter<"subscriptions"> | string
    user_id?: StringFilter<"subscriptions"> | string
    stripe_subscription_id?: StringNullableFilter<"subscriptions"> | string | null
    stripe_customer_id?: StringNullableFilter<"subscriptions"> | string | null
    plan?: EnumSubscriptionPlanFilter<"subscriptions"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    current_period_start?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    cancel_at_period_end?: BoolFilter<"subscriptions"> | boolean
    createdAt?: DateTimeFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"subscriptions"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type subscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    stripe_subscription_id?: string
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    stripe_customer_id?: StringNullableFilter<"subscriptions"> | string | null
    plan?: EnumSubscriptionPlanFilter<"subscriptions"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    current_period_start?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    cancel_at_period_end?: BoolFilter<"subscriptions"> | boolean
    createdAt?: DateTimeFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"subscriptions"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id" | "stripe_subscription_id">

  export type subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subscriptionsCountOrderByAggregateInput
    _max?: subscriptionsMaxOrderByAggregateInput
    _min?: subscriptionsMinOrderByAggregateInput
  }

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    OR?: subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"subscriptions"> | string
    user_id?: StringWithAggregatesFilter<"subscriptions"> | string
    stripe_subscription_id?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null
    stripe_customer_id?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"subscriptions"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusWithAggregatesFilter<"subscriptions"> | $Enums.SubscriptionStatus
    current_period_start?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    current_period_end?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    cancel_at_period_end?: BoolWithAggregatesFilter<"subscriptions"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
  }

  export type tournament_participantsWhereInput = {
    AND?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    OR?: tournament_participantsWhereInput[]
    NOT?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    id?: StringFilter<"tournament_participants"> | string
    tournament_id?: StringFilter<"tournament_participants"> | string
    user_id?: StringFilter<"tournament_participants"> | string
    registered_at?: DateTimeFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableFilter<"tournament_participants"> | Date | string | null
    tournaments?: XOR<TournamentsRelationFilter, tournamentsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type tournament_participantsOrderByWithRelationInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrderInput | SortOrder
    eliminated_at?: SortOrderInput | SortOrder
    tournaments?: tournamentsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type tournament_participantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournament_id_user_id?: tournament_participantsTournament_idUser_idCompoundUniqueInput
    AND?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    OR?: tournament_participantsWhereInput[]
    NOT?: tournament_participantsWhereInput | tournament_participantsWhereInput[]
    tournament_id?: StringFilter<"tournament_participants"> | string
    user_id?: StringFilter<"tournament_participants"> | string
    registered_at?: DateTimeFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableFilter<"tournament_participants"> | Date | string | null
    tournaments?: XOR<TournamentsRelationFilter, tournamentsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "tournament_id_user_id">

  export type tournament_participantsOrderByWithAggregationInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrderInput | SortOrder
    eliminated_at?: SortOrderInput | SortOrder
    _count?: tournament_participantsCountOrderByAggregateInput
    _avg?: tournament_participantsAvgOrderByAggregateInput
    _max?: tournament_participantsMaxOrderByAggregateInput
    _min?: tournament_participantsMinOrderByAggregateInput
    _sum?: tournament_participantsSumOrderByAggregateInput
  }

  export type tournament_participantsScalarWhereWithAggregatesInput = {
    AND?: tournament_participantsScalarWhereWithAggregatesInput | tournament_participantsScalarWhereWithAggregatesInput[]
    OR?: tournament_participantsScalarWhereWithAggregatesInput[]
    NOT?: tournament_participantsScalarWhereWithAggregatesInput | tournament_participantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournament_participants"> | string
    tournament_id?: StringWithAggregatesFilter<"tournament_participants"> | string
    user_id?: StringWithAggregatesFilter<"tournament_participants"> | string
    registered_at?: DateTimeWithAggregatesFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableWithAggregatesFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableWithAggregatesFilter<"tournament_participants"> | Date | string | null
  }

  export type tournamentsWhereInput = {
    AND?: tournamentsWhereInput | tournamentsWhereInput[]
    OR?: tournamentsWhereInput[]
    NOT?: tournamentsWhereInput | tournamentsWhereInput[]
    id?: StringFilter<"tournaments"> | string
    name?: StringFilter<"tournaments"> | string
    description?: StringNullableFilter<"tournaments"> | string | null
    entryFee?: IntFilter<"tournaments"> | number
    prizePool?: IntFilter<"tournaments"> | number
    maxPlayers?: IntNullableFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusFilter<"tournaments"> | $Enums.TournamentStatus
    start_time?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    end_time?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    created_by?: StringFilter<"tournaments"> | string
    createdAt?: DateTimeFilter<"tournaments"> | Date | string
    games?: GamesListRelationFilter
    tournament_participants?: Tournament_participantsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type tournamentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    status?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
    games?: gamesOrderByRelationAggregateInput
    tournament_participants?: tournament_participantsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type tournamentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tournamentsWhereInput | tournamentsWhereInput[]
    OR?: tournamentsWhereInput[]
    NOT?: tournamentsWhereInput | tournamentsWhereInput[]
    name?: StringFilter<"tournaments"> | string
    description?: StringNullableFilter<"tournaments"> | string | null
    entryFee?: IntFilter<"tournaments"> | number
    prizePool?: IntFilter<"tournaments"> | number
    maxPlayers?: IntNullableFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusFilter<"tournaments"> | $Enums.TournamentStatus
    start_time?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    end_time?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    created_by?: StringFilter<"tournaments"> | string
    createdAt?: DateTimeFilter<"tournaments"> | Date | string
    games?: GamesListRelationFilter
    tournament_participants?: Tournament_participantsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type tournamentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    status?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
    _count?: tournamentsCountOrderByAggregateInput
    _avg?: tournamentsAvgOrderByAggregateInput
    _max?: tournamentsMaxOrderByAggregateInput
    _min?: tournamentsMinOrderByAggregateInput
    _sum?: tournamentsSumOrderByAggregateInput
  }

  export type tournamentsScalarWhereWithAggregatesInput = {
    AND?: tournamentsScalarWhereWithAggregatesInput | tournamentsScalarWhereWithAggregatesInput[]
    OR?: tournamentsScalarWhereWithAggregatesInput[]
    NOT?: tournamentsScalarWhereWithAggregatesInput | tournamentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournaments"> | string
    name?: StringWithAggregatesFilter<"tournaments"> | string
    description?: StringNullableWithAggregatesFilter<"tournaments"> | string | null
    entryFee?: IntWithAggregatesFilter<"tournaments"> | number
    prizePool?: IntWithAggregatesFilter<"tournaments"> | number
    maxPlayers?: IntNullableWithAggregatesFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusWithAggregatesFilter<"tournaments"> | $Enums.TournamentStatus
    start_time?: DateTimeNullableWithAggregatesFilter<"tournaments"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"tournaments"> | Date | string | null
    created_by?: StringWithAggregatesFilter<"tournaments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tournaments"> | Date | string
  }

  export type user_analyticsWhereInput = {
    AND?: user_analyticsWhereInput | user_analyticsWhereInput[]
    OR?: user_analyticsWhereInput[]
    NOT?: user_analyticsWhereInput | user_analyticsWhereInput[]
    id?: StringFilter<"user_analytics"> | string
    user_id?: StringFilter<"user_analytics"> | string
    date?: DateTimeFilter<"user_analytics"> | Date | string
    games_played?: IntFilter<"user_analytics"> | number
    games_won?: IntFilter<"user_analytics"> | number
    analyses_completed?: IntFilter<"user_analytics"> | number
    time_played?: IntFilter<"user_analytics"> | number
    avg_equity?: FloatFilter<"user_analytics"> | number
    elo_change?: IntFilter<"user_analytics"> | number
    createdAt?: DateTimeFilter<"user_analytics"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_analyticsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_analyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_date?: user_analyticsUser_idDateCompoundUniqueInput
    AND?: user_analyticsWhereInput | user_analyticsWhereInput[]
    OR?: user_analyticsWhereInput[]
    NOT?: user_analyticsWhereInput | user_analyticsWhereInput[]
    user_id?: StringFilter<"user_analytics"> | string
    date?: DateTimeFilter<"user_analytics"> | Date | string
    games_played?: IntFilter<"user_analytics"> | number
    games_won?: IntFilter<"user_analytics"> | number
    analyses_completed?: IntFilter<"user_analytics"> | number
    time_played?: IntFilter<"user_analytics"> | number
    avg_equity?: FloatFilter<"user_analytics"> | number
    elo_change?: IntFilter<"user_analytics"> | number
    createdAt?: DateTimeFilter<"user_analytics"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id_date">

  export type user_analyticsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    createdAt?: SortOrder
    _count?: user_analyticsCountOrderByAggregateInput
    _avg?: user_analyticsAvgOrderByAggregateInput
    _max?: user_analyticsMaxOrderByAggregateInput
    _min?: user_analyticsMinOrderByAggregateInput
    _sum?: user_analyticsSumOrderByAggregateInput
  }

  export type user_analyticsScalarWhereWithAggregatesInput = {
    AND?: user_analyticsScalarWhereWithAggregatesInput | user_analyticsScalarWhereWithAggregatesInput[]
    OR?: user_analyticsScalarWhereWithAggregatesInput[]
    NOT?: user_analyticsScalarWhereWithAggregatesInput | user_analyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_analytics"> | string
    user_id?: StringWithAggregatesFilter<"user_analytics"> | string
    date?: DateTimeWithAggregatesFilter<"user_analytics"> | Date | string
    games_played?: IntWithAggregatesFilter<"user_analytics"> | number
    games_won?: IntWithAggregatesFilter<"user_analytics"> | number
    analyses_completed?: IntWithAggregatesFilter<"user_analytics"> | number
    time_played?: IntWithAggregatesFilter<"user_analytics"> | number
    avg_equity?: FloatWithAggregatesFilter<"user_analytics"> | number
    elo_change?: IntWithAggregatesFilter<"user_analytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"user_analytics"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    avatar?: StringNullableFilter<"users"> | string | null
    level?: EnumLevelFilter<"users"> | $Enums.Level
    elo?: IntFilter<"users"> | number
    subscriptionType?: EnumSubscriptionTypeFilter<"users"> | $Enums.SubscriptionType
    isActive?: BoolFilter<"users"> | boolean
    emailVerified?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    lastLoginAt?: DateTimeFilter<"users"> | Date | string
    analyses?: AnalysesListRelationFilter
    chat_messages?: Chat_messagesListRelationFilter
    game_moves?: Game_movesListRelationFilter
    games_games_black_player_idTousers?: GamesListRelationFilter
    games_games_white_player_idTousers?: GamesListRelationFilter
    subscriptions?: XOR<SubscriptionsNullableRelationFilter, subscriptionsWhereInput> | null
    tournament_participants?: Tournament_participantsListRelationFilter
    tournaments?: TournamentsListRelationFilter
    user_analytics?: User_analyticsListRelationFilter
    websocket_connections?: Websocket_connectionsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrderInput | SortOrder
    level?: SortOrder
    elo?: SortOrder
    subscriptionType?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    analyses?: analysesOrderByRelationAggregateInput
    chat_messages?: chat_messagesOrderByRelationAggregateInput
    game_moves?: game_movesOrderByRelationAggregateInput
    games_games_black_player_idTousers?: gamesOrderByRelationAggregateInput
    games_games_white_player_idTousers?: gamesOrderByRelationAggregateInput
    subscriptions?: subscriptionsOrderByWithRelationInput
    tournament_participants?: tournament_participantsOrderByRelationAggregateInput
    tournaments?: tournamentsOrderByRelationAggregateInput
    user_analytics?: user_analyticsOrderByRelationAggregateInput
    websocket_connections?: websocket_connectionsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    avatar?: StringNullableFilter<"users"> | string | null
    level?: EnumLevelFilter<"users"> | $Enums.Level
    elo?: IntFilter<"users"> | number
    subscriptionType?: EnumSubscriptionTypeFilter<"users"> | $Enums.SubscriptionType
    isActive?: BoolFilter<"users"> | boolean
    emailVerified?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    lastLoginAt?: DateTimeFilter<"users"> | Date | string
    analyses?: AnalysesListRelationFilter
    chat_messages?: Chat_messagesListRelationFilter
    game_moves?: Game_movesListRelationFilter
    games_games_black_player_idTousers?: GamesListRelationFilter
    games_games_white_player_idTousers?: GamesListRelationFilter
    subscriptions?: XOR<SubscriptionsNullableRelationFilter, subscriptionsWhereInput> | null
    tournament_participants?: Tournament_participantsListRelationFilter
    tournaments?: TournamentsListRelationFilter
    user_analytics?: User_analyticsListRelationFilter
    websocket_connections?: Websocket_connectionsListRelationFilter
  }, "id" | "email" | "username">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrderInput | SortOrder
    level?: SortOrder
    elo?: SortOrder
    subscriptionType?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    username?: StringWithAggregatesFilter<"users"> | string
    avatar?: StringNullableWithAggregatesFilter<"users"> | string | null
    level?: EnumLevelWithAggregatesFilter<"users"> | $Enums.Level
    elo?: IntWithAggregatesFilter<"users"> | number
    subscriptionType?: EnumSubscriptionTypeWithAggregatesFilter<"users"> | $Enums.SubscriptionType
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    lastLoginAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type websocket_connectionsWhereInput = {
    AND?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    OR?: websocket_connectionsWhereInput[]
    NOT?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    id?: StringFilter<"websocket_connections"> | string
    connection_id?: StringFilter<"websocket_connections"> | string
    user_id?: StringFilter<"websocket_connections"> | string
    game_id?: StringNullableFilter<"websocket_connections"> | string | null
    connected_at?: DateTimeFilter<"websocket_connections"> | Date | string
    last_ping?: DateTimeFilter<"websocket_connections"> | Date | string
    is_active?: BoolFilter<"websocket_connections"> | boolean
    games?: XOR<GamesNullableRelationFilter, gamesWhereInput> | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type websocket_connectionsOrderByWithRelationInput = {
    id?: SortOrder
    connection_id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrderInput | SortOrder
    connected_at?: SortOrder
    last_ping?: SortOrder
    is_active?: SortOrder
    games?: gamesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type websocket_connectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    connection_id?: string
    AND?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    OR?: websocket_connectionsWhereInput[]
    NOT?: websocket_connectionsWhereInput | websocket_connectionsWhereInput[]
    user_id?: StringFilter<"websocket_connections"> | string
    game_id?: StringNullableFilter<"websocket_connections"> | string | null
    connected_at?: DateTimeFilter<"websocket_connections"> | Date | string
    last_ping?: DateTimeFilter<"websocket_connections"> | Date | string
    is_active?: BoolFilter<"websocket_connections"> | boolean
    games?: XOR<GamesNullableRelationFilter, gamesWhereInput> | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "connection_id">

  export type websocket_connectionsOrderByWithAggregationInput = {
    id?: SortOrder
    connection_id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrderInput | SortOrder
    connected_at?: SortOrder
    last_ping?: SortOrder
    is_active?: SortOrder
    _count?: websocket_connectionsCountOrderByAggregateInput
    _max?: websocket_connectionsMaxOrderByAggregateInput
    _min?: websocket_connectionsMinOrderByAggregateInput
  }

  export type websocket_connectionsScalarWhereWithAggregatesInput = {
    AND?: websocket_connectionsScalarWhereWithAggregatesInput | websocket_connectionsScalarWhereWithAggregatesInput[]
    OR?: websocket_connectionsScalarWhereWithAggregatesInput[]
    NOT?: websocket_connectionsScalarWhereWithAggregatesInput | websocket_connectionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"websocket_connections"> | string
    connection_id?: StringWithAggregatesFilter<"websocket_connections"> | string
    user_id?: StringWithAggregatesFilter<"websocket_connections"> | string
    game_id?: StringNullableWithAggregatesFilter<"websocket_connections"> | string | null
    connected_at?: DateTimeWithAggregatesFilter<"websocket_connections"> | Date | string
    last_ping?: DateTimeWithAggregatesFilter<"websocket_connections"> | Date | string
    is_active?: BoolWithAggregatesFilter<"websocket_connections"> | boolean
  }

  export type analysesCreateInput = {
    id: string
    board_state: string
    dice?: analysesCreatediceInput | number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: $Enums.AnalysisType
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutAnalysesInput
  }

  export type analysesUncheckedCreateInput = {
    id: string
    user_id: string
    board_state: string
    dice?: analysesCreatediceInput | number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAnalysesNestedInput
  }

  export type analysesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesCreateManyInput = {
    id: string
    user_id: string
    board_state: string
    dice?: analysesCreatediceInput | number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateInput = {
    id: string
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
    games: gamesCreateNestedOneWithoutChat_messagesInput
    users?: usersCreateNestedOneWithoutChat_messagesInput
  }

  export type chat_messagesUncheckedCreateInput = {
    id: string
    game_id: string
    user_id?: string | null
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateOneRequiredWithoutChat_messagesNestedInput
    users?: usersUpdateOneWithoutChat_messagesNestedInput
  }

  export type chat_messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateManyInput = {
    id: string
    game_id: string
    user_id?: string | null
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesCreateInput = {
    id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
    games: gamesCreateNestedOneWithoutGame_movesInput
    users?: usersCreateNestedOneWithoutGame_movesInput
  }

  export type game_movesUncheckedCreateInput = {
    id: string
    game_id: string
    user_id?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
  }

  export type game_movesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateOneRequiredWithoutGame_movesNestedInput
    users?: usersUpdateOneWithoutGame_movesNestedInput
  }

  export type game_movesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesCreateManyInput = {
    id: string
    game_id: string
    user_id?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
  }

  export type game_movesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type gamesCreateInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesCreateNestedManyWithoutGamesInput
    game_moves?: game_movesCreateNestedManyWithoutGamesInput
    users_games_black_player_idTousers?: usersCreateNestedOneWithoutGames_games_black_player_idTousersInput
    tournaments?: tournamentsCreateNestedOneWithoutGamesInput
    users_games_white_player_idTousers?: usersCreateNestedOneWithoutGames_games_white_player_idTousersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutGamesInput
  }

  export type gamesUncheckedCreateInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutGamesInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutGamesInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUpdateManyWithoutGamesNestedInput
    users_games_black_player_idTousers?: usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput
    tournaments?: tournamentsUpdateOneWithoutGamesNestedInput
    users_games_white_player_idTousers?: usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type gamesCreateManyInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
  }

  export type gamesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
  }

  export type gamesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subscriptionsCreateInput = {
    id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateInput = {
    id: string
    user_id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsCreateManyInput = {
    id: string
    user_id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_participantsCreateInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutTournament_participantsInput
    users: usersCreateNestedOneWithoutTournament_participantsInput
  }

  export type tournament_participantsUncheckedCreateInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournament_participantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutTournament_participantsNestedInput
    users?: usersUpdateOneRequiredWithoutTournament_participantsNestedInput
  }

  export type tournament_participantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_participantsCreateManyInput = {
    id: string
    tournament_id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournament_participantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_participantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournamentsCreateInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentsInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
    users: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    created_by: string
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentsInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
  }

  export type tournamentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentsNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentsNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
  }

  export type tournamentsCreateManyInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    created_by: string
    createdAt?: Date | string
  }

  export type tournamentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsCreateInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutUser_analyticsInput
  }

  export type user_analyticsUncheckedCreateInput = {
    id: string
    user_id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    createdAt?: Date | string
  }

  export type user_analyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_analyticsNestedInput
  }

  export type user_analyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsCreateManyInput = {
    id: string
    user_id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    createdAt?: Date | string
  }

  export type user_analyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type websocket_connectionsCreateInput = {
    id: string
    connection_id: string
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
    games?: gamesCreateNestedOneWithoutWebsocket_connectionsInput
    users: usersCreateNestedOneWithoutWebsocket_connectionsInput
  }

  export type websocket_connectionsUncheckedCreateInput = {
    id: string
    connection_id: string
    user_id: string
    game_id?: string | null
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
  }

  export type websocket_connectionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    games?: gamesUpdateOneWithoutWebsocket_connectionsNestedInput
    users?: usersUpdateOneRequiredWithoutWebsocket_connectionsNestedInput
  }

  export type websocket_connectionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    game_id?: NullableStringFieldUpdateOperationsInput | string | null
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsCreateManyInput = {
    id: string
    connection_id: string
    user_id: string
    game_id?: string | null
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
  }

  export type websocket_connectionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    game_id?: NullableStringFieldUpdateOperationsInput | string | null
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type analysesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    board_state?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    best_move?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    alternatives?: SortOrder
    analysis_type?: SortOrder
    createdAt?: SortOrder
  }

  export type analysesAvgOrderByAggregateInput = {
    dice?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
  }

  export type analysesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    board_state?: SortOrder
    move?: SortOrder
    best_move?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    analysis_type?: SortOrder
    createdAt?: SortOrder
  }

  export type analysesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    board_state?: SortOrder
    move?: SortOrder
    best_move?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    explanation?: SortOrder
    analysis_type?: SortOrder
    createdAt?: SortOrder
  }

  export type analysesSumOrderByAggregateInput = {
    dice?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type GamesRelationFilter = {
    is?: gamesWhereInput
    isNot?: gamesWhereInput
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type chat_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    message_type?: SortOrder
    createdAt?: SortOrder
  }

  export type chat_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    message_type?: SortOrder
    createdAt?: SortOrder
  }

  export type chat_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    message_type?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumPlayerFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerFilter<$PrismaModel> | $Enums.Player
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type game_movesCountOrderByAggregateInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrder
    player?: SortOrder
    dice?: SortOrder
    move?: SortOrder
    from_point?: SortOrder
    to_point?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinking_time?: SortOrder
    createdAt?: SortOrder
  }

  export type game_movesAvgOrderByAggregateInput = {
    dice?: SortOrder
    from_point?: SortOrder
    to_point?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinking_time?: SortOrder
  }

  export type game_movesMaxOrderByAggregateInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrder
    player?: SortOrder
    move?: SortOrder
    from_point?: SortOrder
    to_point?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinking_time?: SortOrder
    createdAt?: SortOrder
  }

  export type game_movesMinOrderByAggregateInput = {
    id?: SortOrder
    game_id?: SortOrder
    user_id?: SortOrder
    player?: SortOrder
    move?: SortOrder
    from_point?: SortOrder
    to_point?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinking_time?: SortOrder
    createdAt?: SortOrder
  }

  export type game_movesSumOrderByAggregateInput = {
    dice?: SortOrder
    from_point?: SortOrder
    to_point?: SortOrder
    equity?: SortOrder
    pr?: SortOrder
    thinking_time?: SortOrder
  }

  export type EnumPlayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerWithAggregatesFilter<$PrismaModel> | $Enums.Player
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerFilter<$PrismaModel>
    _max?: NestedEnumPlayerFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type EnumGameModeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeFilter<$PrismaModel> | $Enums.GameMode
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPlayerNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableFilter<$PrismaModel> | $Enums.Player | null
  }

  export type Chat_messagesListRelationFilter = {
    every?: chat_messagesWhereInput
    some?: chat_messagesWhereInput
    none?: chat_messagesWhereInput
  }

  export type Game_movesListRelationFilter = {
    every?: game_movesWhereInput
    some?: game_movesWhereInput
    none?: game_movesWhereInput
  }

  export type TournamentsNullableRelationFilter = {
    is?: tournamentsWhereInput | null
    isNot?: tournamentsWhereInput | null
  }

  export type Websocket_connectionsListRelationFilter = {
    every?: websocket_connectionsWhereInput
    some?: websocket_connectionsWhereInput
    none?: websocket_connectionsWhereInput
  }

  export type chat_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type game_movesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type websocket_connectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gamesCountOrderByAggregateInput = {
    id?: SortOrder
    white_player_id?: SortOrder
    black_player_id?: SortOrder
    status?: SortOrder
    board_state?: SortOrder
    gameMode?: SortOrder
    current_player?: SortOrder
    dice?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
    createdAt?: SortOrder
    finished_at?: SortOrder
    winner?: SortOrder
    tournament_id?: SortOrder
  }

  export type gamesAvgOrderByAggregateInput = {
    dice?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
  }

  export type gamesMaxOrderByAggregateInput = {
    id?: SortOrder
    white_player_id?: SortOrder
    black_player_id?: SortOrder
    status?: SortOrder
    board_state?: SortOrder
    gameMode?: SortOrder
    current_player?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
    createdAt?: SortOrder
    finished_at?: SortOrder
    winner?: SortOrder
    tournament_id?: SortOrder
  }

  export type gamesMinOrderByAggregateInput = {
    id?: SortOrder
    white_player_id?: SortOrder
    black_player_id?: SortOrder
    status?: SortOrder
    board_state?: SortOrder
    gameMode?: SortOrder
    current_player?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
    createdAt?: SortOrder
    finished_at?: SortOrder
    winner?: SortOrder
    tournament_id?: SortOrder
  }

  export type gamesSumOrderByAggregateInput = {
    dice?: SortOrder
    white_score?: SortOrder
    black_score?: SortOrder
  }

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type EnumGameModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeWithAggregatesFilter<$PrismaModel> | $Enums.GameMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameModeFilter<$PrismaModel>
    _max?: NestedEnumGameModeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPlayerNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableWithAggregatesFilter<$PrismaModel> | $Enums.Player | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_customer_id?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_customer_id?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_customer_id?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TournamentsRelationFilter = {
    is?: tournamentsWhereInput
    isNot?: tournamentsWhereInput
  }

  export type tournament_participantsTournament_idUser_idCompoundUniqueInput = {
    tournament_id: string
    user_id: string
  }

  export type tournament_participantsCountOrderByAggregateInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrder
    eliminated_at?: SortOrder
  }

  export type tournament_participantsAvgOrderByAggregateInput = {
    current_position?: SortOrder
  }

  export type tournament_participantsMaxOrderByAggregateInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrder
    eliminated_at?: SortOrder
  }

  export type tournament_participantsMinOrderByAggregateInput = {
    id?: SortOrder
    tournament_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    current_position?: SortOrder
    eliminated_at?: SortOrder
  }

  export type tournament_participantsSumOrderByAggregateInput = {
    current_position?: SortOrder
  }

  export type EnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type GamesListRelationFilter = {
    every?: gamesWhereInput
    some?: gamesWhereInput
    none?: gamesWhereInput
  }

  export type Tournament_participantsListRelationFilter = {
    every?: tournament_participantsWhereInput
    some?: tournament_participantsWhereInput
    none?: tournament_participantsWhereInput
  }

  export type gamesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournament_participantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type tournamentsAvgOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
  }

  export type tournamentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type tournamentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type tournamentsSumOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
    maxPlayers?: SortOrder
  }

  export type EnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type user_analyticsUser_idDateCompoundUniqueInput = {
    user_id: string
    date: Date | string
  }

  export type user_analyticsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    createdAt?: SortOrder
  }

  export type user_analyticsAvgOrderByAggregateInput = {
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
  }

  export type user_analyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    createdAt?: SortOrder
  }

  export type user_analyticsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
    createdAt?: SortOrder
  }

  export type user_analyticsSumOrderByAggregateInput = {
    games_played?: SortOrder
    games_won?: SortOrder
    analyses_completed?: SortOrder
    time_played?: SortOrder
    avg_equity?: SortOrder
    elo_change?: SortOrder
  }

  export type EnumLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelFilter<$PrismaModel> | $Enums.Level
  }

  export type EnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type AnalysesListRelationFilter = {
    every?: analysesWhereInput
    some?: analysesWhereInput
    none?: analysesWhereInput
  }

  export type SubscriptionsNullableRelationFilter = {
    is?: subscriptionsWhereInput | null
    isNot?: subscriptionsWhereInput | null
  }

  export type TournamentsListRelationFilter = {
    every?: tournamentsWhereInput
    some?: tournamentsWhereInput
    none?: tournamentsWhereInput
  }

  export type User_analyticsListRelationFilter = {
    every?: user_analyticsWhereInput
    some?: user_analyticsWhereInput
    none?: user_analyticsWhereInput
  }

  export type analysesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_analyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    level?: SortOrder
    elo?: SortOrder
    subscriptionType?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    elo?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    level?: SortOrder
    elo?: SortOrder
    subscriptionType?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    level?: SortOrder
    elo?: SortOrder
    subscriptionType?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    elo?: SortOrder
  }

  export type EnumLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelWithAggregatesFilter<$PrismaModel> | $Enums.Level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelFilter<$PrismaModel>
    _max?: NestedEnumLevelFilter<$PrismaModel>
  }

  export type EnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type GamesNullableRelationFilter = {
    is?: gamesWhereInput | null
    isNot?: gamesWhereInput | null
  }

  export type websocket_connectionsCountOrderByAggregateInput = {
    id?: SortOrder
    connection_id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    connected_at?: SortOrder
    last_ping?: SortOrder
    is_active?: SortOrder
  }

  export type websocket_connectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    connection_id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    connected_at?: SortOrder
    last_ping?: SortOrder
    is_active?: SortOrder
  }

  export type websocket_connectionsMinOrderByAggregateInput = {
    id?: SortOrder
    connection_id?: SortOrder
    user_id?: SortOrder
    game_id?: SortOrder
    connected_at?: SortOrder
    last_ping?: SortOrder
    is_active?: SortOrder
  }

  export type analysesCreatediceInput = {
    set: number[]
  }

  export type usersCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalysesInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type analysesUpdatediceInput = {
    set?: number[]
    push?: number | number[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAnalysisTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnalysisType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneRequiredWithoutAnalysesNestedInput = {
    create?: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalysesInput
    upsert?: usersUpsertWithoutAnalysesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAnalysesInput, usersUpdateWithoutAnalysesInput>, usersUncheckedUpdateWithoutAnalysesInput>
  }

  export type gamesCreateNestedOneWithoutChat_messagesInput = {
    create?: XOR<gamesCreateWithoutChat_messagesInput, gamesUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutChat_messagesInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutChat_messagesInput = {
    create?: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChat_messagesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type gamesUpdateOneRequiredWithoutChat_messagesNestedInput = {
    create?: XOR<gamesCreateWithoutChat_messagesInput, gamesUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutChat_messagesInput
    upsert?: gamesUpsertWithoutChat_messagesInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutChat_messagesInput, gamesUpdateWithoutChat_messagesInput>, gamesUncheckedUpdateWithoutChat_messagesInput>
  }

  export type usersUpdateOneWithoutChat_messagesNestedInput = {
    create?: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChat_messagesInput
    upsert?: usersUpsertWithoutChat_messagesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChat_messagesInput, usersUpdateWithoutChat_messagesInput>, usersUncheckedUpdateWithoutChat_messagesInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type game_movesCreatediceInput = {
    set: number[]
  }

  export type gamesCreateNestedOneWithoutGame_movesInput = {
    create?: XOR<gamesCreateWithoutGame_movesInput, gamesUncheckedCreateWithoutGame_movesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutGame_movesInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutGame_movesInput = {
    create?: XOR<usersCreateWithoutGame_movesInput, usersUncheckedCreateWithoutGame_movesInput>
    connectOrCreate?: usersCreateOrConnectWithoutGame_movesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumPlayerFieldUpdateOperationsInput = {
    set?: $Enums.Player
  }

  export type game_movesUpdatediceInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type gamesUpdateOneRequiredWithoutGame_movesNestedInput = {
    create?: XOR<gamesCreateWithoutGame_movesInput, gamesUncheckedCreateWithoutGame_movesInput>
    connectOrCreate?: gamesCreateOrConnectWithoutGame_movesInput
    upsert?: gamesUpsertWithoutGame_movesInput
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutGame_movesInput, gamesUpdateWithoutGame_movesInput>, gamesUncheckedUpdateWithoutGame_movesInput>
  }

  export type usersUpdateOneWithoutGame_movesNestedInput = {
    create?: XOR<usersCreateWithoutGame_movesInput, usersUncheckedCreateWithoutGame_movesInput>
    connectOrCreate?: usersCreateOrConnectWithoutGame_movesInput
    upsert?: usersUpsertWithoutGame_movesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGame_movesInput, usersUpdateWithoutGame_movesInput>, usersUncheckedUpdateWithoutGame_movesInput>
  }

  export type gamesCreatediceInput = {
    set: number[]
  }

  export type chat_messagesCreateNestedManyWithoutGamesInput = {
    create?: XOR<chat_messagesCreateWithoutGamesInput, chat_messagesUncheckedCreateWithoutGamesInput> | chat_messagesCreateWithoutGamesInput[] | chat_messagesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGamesInput | chat_messagesCreateOrConnectWithoutGamesInput[]
    createMany?: chat_messagesCreateManyGamesInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesCreateNestedManyWithoutGamesInput = {
    create?: XOR<game_movesCreateWithoutGamesInput, game_movesUncheckedCreateWithoutGamesInput> | game_movesCreateWithoutGamesInput[] | game_movesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGamesInput | game_movesCreateOrConnectWithoutGamesInput[]
    createMany?: game_movesCreateManyGamesInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutGames_games_black_player_idTousersInput = {
    create?: XOR<usersCreateWithoutGames_games_black_player_idTousersInput, usersUncheckedCreateWithoutGames_games_black_player_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutGames_games_black_player_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type tournamentsCreateNestedOneWithoutGamesInput = {
    create?: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutGamesInput
    connect?: tournamentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutGames_games_white_player_idTousersInput = {
    create?: XOR<usersCreateWithoutGames_games_white_player_idTousersInput, usersUncheckedCreateWithoutGames_games_white_player_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutGames_games_white_player_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type websocket_connectionsCreateNestedManyWithoutGamesInput = {
    create?: XOR<websocket_connectionsCreateWithoutGamesInput, websocket_connectionsUncheckedCreateWithoutGamesInput> | websocket_connectionsCreateWithoutGamesInput[] | websocket_connectionsUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGamesInput | websocket_connectionsCreateOrConnectWithoutGamesInput[]
    createMany?: websocket_connectionsCreateManyGamesInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<chat_messagesCreateWithoutGamesInput, chat_messagesUncheckedCreateWithoutGamesInput> | chat_messagesCreateWithoutGamesInput[] | chat_messagesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGamesInput | chat_messagesCreateOrConnectWithoutGamesInput[]
    createMany?: chat_messagesCreateManyGamesInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<game_movesCreateWithoutGamesInput, game_movesUncheckedCreateWithoutGamesInput> | game_movesCreateWithoutGamesInput[] | game_movesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGamesInput | game_movesCreateOrConnectWithoutGamesInput[]
    createMany?: game_movesCreateManyGamesInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput = {
    create?: XOR<websocket_connectionsCreateWithoutGamesInput, websocket_connectionsUncheckedCreateWithoutGamesInput> | websocket_connectionsCreateWithoutGamesInput[] | websocket_connectionsUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGamesInput | websocket_connectionsCreateOrConnectWithoutGamesInput[]
    createMany?: websocket_connectionsCreateManyGamesInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus
  }

  export type EnumGameModeFieldUpdateOperationsInput = {
    set?: $Enums.GameMode
  }

  export type gamesUpdatediceInput = {
    set?: number[]
    push?: number | number[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumPlayerFieldUpdateOperationsInput = {
    set?: $Enums.Player | null
  }

  export type chat_messagesUpdateManyWithoutGamesNestedInput = {
    create?: XOR<chat_messagesCreateWithoutGamesInput, chat_messagesUncheckedCreateWithoutGamesInput> | chat_messagesCreateWithoutGamesInput[] | chat_messagesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGamesInput | chat_messagesCreateOrConnectWithoutGamesInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutGamesInput | chat_messagesUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: chat_messagesCreateManyGamesInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutGamesInput | chat_messagesUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutGamesInput | chat_messagesUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUpdateManyWithoutGamesNestedInput = {
    create?: XOR<game_movesCreateWithoutGamesInput, game_movesUncheckedCreateWithoutGamesInput> | game_movesCreateWithoutGamesInput[] | game_movesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGamesInput | game_movesCreateOrConnectWithoutGamesInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutGamesInput | game_movesUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: game_movesCreateManyGamesInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutGamesInput | game_movesUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutGamesInput | game_movesUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutGames_games_black_player_idTousersInput, usersUncheckedCreateWithoutGames_games_black_player_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutGames_games_black_player_idTousersInput
    upsert?: usersUpsertWithoutGames_games_black_player_idTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGames_games_black_player_idTousersInput, usersUpdateWithoutGames_games_black_player_idTousersInput>, usersUncheckedUpdateWithoutGames_games_black_player_idTousersInput>
  }

  export type tournamentsUpdateOneWithoutGamesNestedInput = {
    create?: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutGamesInput
    upsert?: tournamentsUpsertWithoutGamesInput
    disconnect?: tournamentsWhereInput | boolean
    delete?: tournamentsWhereInput | boolean
    connect?: tournamentsWhereUniqueInput
    update?: XOR<XOR<tournamentsUpdateToOneWithWhereWithoutGamesInput, tournamentsUpdateWithoutGamesInput>, tournamentsUncheckedUpdateWithoutGamesInput>
  }

  export type usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutGames_games_white_player_idTousersInput, usersUncheckedCreateWithoutGames_games_white_player_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutGames_games_white_player_idTousersInput
    upsert?: usersUpsertWithoutGames_games_white_player_idTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGames_games_white_player_idTousersInput, usersUpdateWithoutGames_games_white_player_idTousersInput>, usersUncheckedUpdateWithoutGames_games_white_player_idTousersInput>
  }

  export type websocket_connectionsUpdateManyWithoutGamesNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutGamesInput, websocket_connectionsUncheckedCreateWithoutGamesInput> | websocket_connectionsCreateWithoutGamesInput[] | websocket_connectionsUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGamesInput | websocket_connectionsCreateOrConnectWithoutGamesInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutGamesInput | websocket_connectionsUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: websocket_connectionsCreateManyGamesInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutGamesInput | websocket_connectionsUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutGamesInput | websocket_connectionsUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<chat_messagesCreateWithoutGamesInput, chat_messagesUncheckedCreateWithoutGamesInput> | chat_messagesCreateWithoutGamesInput[] | chat_messagesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutGamesInput | chat_messagesCreateOrConnectWithoutGamesInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutGamesInput | chat_messagesUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: chat_messagesCreateManyGamesInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutGamesInput | chat_messagesUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutGamesInput | chat_messagesUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<game_movesCreateWithoutGamesInput, game_movesUncheckedCreateWithoutGamesInput> | game_movesCreateWithoutGamesInput[] | game_movesUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutGamesInput | game_movesCreateOrConnectWithoutGamesInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutGamesInput | game_movesUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: game_movesCreateManyGamesInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutGamesInput | game_movesUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutGamesInput | game_movesUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutGamesInput, websocket_connectionsUncheckedCreateWithoutGamesInput> | websocket_connectionsCreateWithoutGamesInput[] | websocket_connectionsUncheckedCreateWithoutGamesInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutGamesInput | websocket_connectionsCreateOrConnectWithoutGamesInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutGamesInput | websocket_connectionsUpsertWithWhereUniqueWithoutGamesInput[]
    createMany?: websocket_connectionsCreateManyGamesInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutGamesInput | websocket_connectionsUpdateWithWhereUniqueWithoutGamesInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutGamesInput | websocket_connectionsUpdateManyWithWhereWithoutGamesInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubscriptionsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubscriptionsInput
    upsert?: usersUpsertWithoutSubscriptionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSubscriptionsInput, usersUpdateWithoutSubscriptionsInput>, usersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type tournamentsCreateNestedOneWithoutTournament_participantsInput = {
    create?: XOR<tournamentsCreateWithoutTournament_participantsInput, tournamentsUncheckedCreateWithoutTournament_participantsInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutTournament_participantsInput
    connect?: tournamentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTournament_participantsInput = {
    create?: XOR<usersCreateWithoutTournament_participantsInput, usersUncheckedCreateWithoutTournament_participantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournament_participantsInput
    connect?: usersWhereUniqueInput
  }

  export type tournamentsUpdateOneRequiredWithoutTournament_participantsNestedInput = {
    create?: XOR<tournamentsCreateWithoutTournament_participantsInput, tournamentsUncheckedCreateWithoutTournament_participantsInput>
    connectOrCreate?: tournamentsCreateOrConnectWithoutTournament_participantsInput
    upsert?: tournamentsUpsertWithoutTournament_participantsInput
    connect?: tournamentsWhereUniqueInput
    update?: XOR<XOR<tournamentsUpdateToOneWithWhereWithoutTournament_participantsInput, tournamentsUpdateWithoutTournament_participantsInput>, tournamentsUncheckedUpdateWithoutTournament_participantsInput>
  }

  export type usersUpdateOneRequiredWithoutTournament_participantsNestedInput = {
    create?: XOR<usersCreateWithoutTournament_participantsInput, usersUncheckedCreateWithoutTournament_participantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournament_participantsInput
    upsert?: usersUpsertWithoutTournament_participantsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTournament_participantsInput, usersUpdateWithoutTournament_participantsInput>, usersUncheckedUpdateWithoutTournament_participantsInput>
  }

  export type gamesCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<gamesCreateWithoutTournamentsInput, gamesUncheckedCreateWithoutTournamentsInput> | gamesCreateWithoutTournamentsInput[] | gamesUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentsInput | gamesCreateOrConnectWithoutTournamentsInput[]
    createMany?: gamesCreateManyTournamentsInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type tournament_participantsCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTournamentsInput = {
    create?: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournamentsInput
    connect?: usersWhereUniqueInput
  }

  export type gamesUncheckedCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<gamesCreateWithoutTournamentsInput, gamesUncheckedCreateWithoutTournamentsInput> | gamesCreateWithoutTournamentsInput[] | gamesUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentsInput | gamesCreateOrConnectWithoutTournamentsInput[]
    createMany?: gamesCreateManyTournamentsInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type EnumTournamentStatusFieldUpdateOperationsInput = {
    set?: $Enums.TournamentStatus
  }

  export type gamesUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<gamesCreateWithoutTournamentsInput, gamesUncheckedCreateWithoutTournamentsInput> | gamesCreateWithoutTournamentsInput[] | gamesUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentsInput | gamesCreateOrConnectWithoutTournamentsInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutTournamentsInput | gamesUpsertWithWhereUniqueWithoutTournamentsInput[]
    createMany?: gamesCreateManyTournamentsInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutTournamentsInput | gamesUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutTournamentsInput | gamesUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type tournament_participantsUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutTournamentsInput | tournament_participantsUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutTournamentsNestedInput = {
    create?: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTournamentsInput
    upsert?: usersUpsertWithoutTournamentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTournamentsInput, usersUpdateWithoutTournamentsInput>, usersUncheckedUpdateWithoutTournamentsInput>
  }

  export type gamesUncheckedUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<gamesCreateWithoutTournamentsInput, gamesUncheckedCreateWithoutTournamentsInput> | gamesCreateWithoutTournamentsInput[] | gamesUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutTournamentsInput | gamesCreateOrConnectWithoutTournamentsInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutTournamentsInput | gamesUpsertWithWhereUniqueWithoutTournamentsInput[]
    createMany?: gamesCreateManyTournamentsInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutTournamentsInput | gamesUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutTournamentsInput | gamesUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput> | tournament_participantsCreateWithoutTournamentsInput[] | tournament_participantsUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutTournamentsInput | tournament_participantsCreateOrConnectWithoutTournamentsInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput[]
    createMany?: tournament_participantsCreateManyTournamentsInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput | tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutTournamentsInput | tournament_participantsUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_analyticsInput = {
    create?: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_analyticsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_analyticsNestedInput = {
    create?: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_analyticsInput
    upsert?: usersUpsertWithoutUser_analyticsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_analyticsInput, usersUpdateWithoutUser_analyticsInput>, usersUncheckedUpdateWithoutUser_analyticsInput>
  }

  export type analysesCreateNestedManyWithoutUsersInput = {
    create?: XOR<analysesCreateWithoutUsersInput, analysesUncheckedCreateWithoutUsersInput> | analysesCreateWithoutUsersInput[] | analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUsersInput | analysesCreateOrConnectWithoutUsersInput[]
    createMany?: analysesCreateManyUsersInputEnvelope
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
  }

  export type chat_messagesCreateNestedManyWithoutUsersInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesCreateNestedManyWithoutUsersInput = {
    create?: XOR<game_movesCreateWithoutUsersInput, game_movesUncheckedCreateWithoutUsersInput> | game_movesCreateWithoutUsersInput[] | game_movesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUsersInput | game_movesCreateOrConnectWithoutUsersInput[]
    createMany?: game_movesCreateManyUsersInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput = {
    create?: XOR<gamesCreateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput> | gamesCreateWithoutUsers_games_black_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_black_player_idTousersInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput = {
    create?: XOR<gamesCreateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput> | gamesCreateWithoutUsers_games_white_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_white_player_idTousersInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type subscriptionsCreateNestedOneWithoutUsersInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type tournament_participantsCreateNestedManyWithoutUsersInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type tournamentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<tournamentsCreateWithoutUsersInput, tournamentsUncheckedCreateWithoutUsersInput> | tournamentsCreateWithoutUsersInput[] | tournamentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutUsersInput | tournamentsCreateOrConnectWithoutUsersInput[]
    createMany?: tournamentsCreateManyUsersInputEnvelope
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
  }

  export type user_analyticsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
  }

  export type websocket_connectionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<websocket_connectionsCreateWithoutUsersInput, websocket_connectionsUncheckedCreateWithoutUsersInput> | websocket_connectionsCreateWithoutUsersInput[] | websocket_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUsersInput | websocket_connectionsCreateOrConnectWithoutUsersInput[]
    createMany?: websocket_connectionsCreateManyUsersInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type analysesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<analysesCreateWithoutUsersInput, analysesUncheckedCreateWithoutUsersInput> | analysesCreateWithoutUsersInput[] | analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUsersInput | analysesCreateOrConnectWithoutUsersInput[]
    createMany?: analysesCreateManyUsersInputEnvelope
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type game_movesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<game_movesCreateWithoutUsersInput, game_movesUncheckedCreateWithoutUsersInput> | game_movesCreateWithoutUsersInput[] | game_movesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUsersInput | game_movesCreateOrConnectWithoutUsersInput[]
    createMany?: game_movesCreateManyUsersInputEnvelope
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
  }

  export type gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput = {
    create?: XOR<gamesCreateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput> | gamesCreateWithoutUsers_games_black_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_black_player_idTousersInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput = {
    create?: XOR<gamesCreateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput> | gamesCreateWithoutUsers_games_white_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_white_player_idTousersInputEnvelope
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
  }

  export type subscriptionsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type tournament_participantsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
  }

  export type tournamentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tournamentsCreateWithoutUsersInput, tournamentsUncheckedCreateWithoutUsersInput> | tournamentsCreateWithoutUsersInput[] | tournamentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutUsersInput | tournamentsCreateOrConnectWithoutUsersInput[]
    createMany?: tournamentsCreateManyUsersInputEnvelope
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
  }

  export type user_analyticsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
  }

  export type websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<websocket_connectionsCreateWithoutUsersInput, websocket_connectionsUncheckedCreateWithoutUsersInput> | websocket_connectionsCreateWithoutUsersInput[] | websocket_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUsersInput | websocket_connectionsCreateOrConnectWithoutUsersInput[]
    createMany?: websocket_connectionsCreateManyUsersInputEnvelope
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
  }

  export type EnumLevelFieldUpdateOperationsInput = {
    set?: $Enums.Level
  }

  export type EnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType
  }

  export type analysesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<analysesCreateWithoutUsersInput, analysesUncheckedCreateWithoutUsersInput> | analysesCreateWithoutUsersInput[] | analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUsersInput | analysesCreateOrConnectWithoutUsersInput[]
    upsert?: analysesUpsertWithWhereUniqueWithoutUsersInput | analysesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: analysesCreateManyUsersInputEnvelope
    set?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    disconnect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    delete?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    update?: analysesUpdateWithWhereUniqueWithoutUsersInput | analysesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: analysesUpdateManyWithWhereWithoutUsersInput | analysesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: analysesScalarWhereInput | analysesScalarWhereInput[]
  }

  export type chat_messagesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutUsersInput | chat_messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutUsersInput | chat_messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutUsersInput | chat_messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<game_movesCreateWithoutUsersInput, game_movesUncheckedCreateWithoutUsersInput> | game_movesCreateWithoutUsersInput[] | game_movesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUsersInput | game_movesCreateOrConnectWithoutUsersInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutUsersInput | game_movesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: game_movesCreateManyUsersInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutUsersInput | game_movesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutUsersInput | game_movesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput = {
    create?: XOR<gamesCreateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput> | gamesCreateWithoutUsers_games_black_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutUsers_games_black_player_idTousersInput | gamesUpsertWithWhereUniqueWithoutUsers_games_black_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_black_player_idTousersInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutUsers_games_black_player_idTousersInput | gamesUpdateWithWhereUniqueWithoutUsers_games_black_player_idTousersInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutUsers_games_black_player_idTousersInput | gamesUpdateManyWithWhereWithoutUsers_games_black_player_idTousersInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput = {
    create?: XOR<gamesCreateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput> | gamesCreateWithoutUsers_games_white_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutUsers_games_white_player_idTousersInput | gamesUpsertWithWhereUniqueWithoutUsers_games_white_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_white_player_idTousersInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutUsers_games_white_player_idTousersInput | gamesUpdateWithWhereUniqueWithoutUsers_games_white_player_idTousersInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutUsers_games_white_player_idTousersInput | gamesUpdateManyWithWhereWithoutUsers_games_white_player_idTousersInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type subscriptionsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    upsert?: subscriptionsUpsertWithoutUsersInput
    disconnect?: subscriptionsWhereInput | boolean
    delete?: subscriptionsWhereInput | boolean
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutUsersInput, subscriptionsUpdateWithoutUsersInput>, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type tournament_participantsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutUsersInput | tournament_participantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutUsersInput | tournament_participantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutUsersInput | tournament_participantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type tournamentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tournamentsCreateWithoutUsersInput, tournamentsUncheckedCreateWithoutUsersInput> | tournamentsCreateWithoutUsersInput[] | tournamentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutUsersInput | tournamentsCreateOrConnectWithoutUsersInput[]
    upsert?: tournamentsUpsertWithWhereUniqueWithoutUsersInput | tournamentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tournamentsCreateManyUsersInputEnvelope
    set?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    disconnect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    delete?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    update?: tournamentsUpdateWithWhereUniqueWithoutUsersInput | tournamentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tournamentsUpdateManyWithWhereWithoutUsersInput | tournamentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
  }

  export type user_analyticsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    upsert?: user_analyticsUpsertWithWhereUniqueWithoutUsersInput | user_analyticsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    set?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    disconnect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    delete?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    update?: user_analyticsUpdateWithWhereUniqueWithoutUsersInput | user_analyticsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_analyticsUpdateManyWithWhereWithoutUsersInput | user_analyticsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
  }

  export type websocket_connectionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutUsersInput, websocket_connectionsUncheckedCreateWithoutUsersInput> | websocket_connectionsCreateWithoutUsersInput[] | websocket_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUsersInput | websocket_connectionsCreateOrConnectWithoutUsersInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutUsersInput | websocket_connectionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: websocket_connectionsCreateManyUsersInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutUsersInput | websocket_connectionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutUsersInput | websocket_connectionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type analysesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<analysesCreateWithoutUsersInput, analysesUncheckedCreateWithoutUsersInput> | analysesCreateWithoutUsersInput[] | analysesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: analysesCreateOrConnectWithoutUsersInput | analysesCreateOrConnectWithoutUsersInput[]
    upsert?: analysesUpsertWithWhereUniqueWithoutUsersInput | analysesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: analysesCreateManyUsersInputEnvelope
    set?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    disconnect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    delete?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    connect?: analysesWhereUniqueInput | analysesWhereUniqueInput[]
    update?: analysesUpdateWithWhereUniqueWithoutUsersInput | analysesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: analysesUpdateManyWithWhereWithoutUsersInput | analysesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: analysesScalarWhereInput | analysesScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput> | chat_messagesCreateWithoutUsersInput[] | chat_messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutUsersInput | chat_messagesCreateOrConnectWithoutUsersInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutUsersInput | chat_messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chat_messagesCreateManyUsersInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutUsersInput | chat_messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutUsersInput | chat_messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type game_movesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<game_movesCreateWithoutUsersInput, game_movesUncheckedCreateWithoutUsersInput> | game_movesCreateWithoutUsersInput[] | game_movesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: game_movesCreateOrConnectWithoutUsersInput | game_movesCreateOrConnectWithoutUsersInput[]
    upsert?: game_movesUpsertWithWhereUniqueWithoutUsersInput | game_movesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: game_movesCreateManyUsersInputEnvelope
    set?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    disconnect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    delete?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    connect?: game_movesWhereUniqueInput | game_movesWhereUniqueInput[]
    update?: game_movesUpdateWithWhereUniqueWithoutUsersInput | game_movesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: game_movesUpdateManyWithWhereWithoutUsersInput | game_movesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
  }

  export type gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput = {
    create?: XOR<gamesCreateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput> | gamesCreateWithoutUsers_games_black_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutUsers_games_black_player_idTousersInput | gamesUpsertWithWhereUniqueWithoutUsers_games_black_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_black_player_idTousersInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutUsers_games_black_player_idTousersInput | gamesUpdateWithWhereUniqueWithoutUsers_games_black_player_idTousersInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutUsers_games_black_player_idTousersInput | gamesUpdateManyWithWhereWithoutUsers_games_black_player_idTousersInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput = {
    create?: XOR<gamesCreateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput> | gamesCreateWithoutUsers_games_white_player_idTousersInput[] | gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput[]
    connectOrCreate?: gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput | gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput[]
    upsert?: gamesUpsertWithWhereUniqueWithoutUsers_games_white_player_idTousersInput | gamesUpsertWithWhereUniqueWithoutUsers_games_white_player_idTousersInput[]
    createMany?: gamesCreateManyUsers_games_white_player_idTousersInputEnvelope
    set?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    disconnect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    delete?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    connect?: gamesWhereUniqueInput | gamesWhereUniqueInput[]
    update?: gamesUpdateWithWhereUniqueWithoutUsers_games_white_player_idTousersInput | gamesUpdateWithWhereUniqueWithoutUsers_games_white_player_idTousersInput[]
    updateMany?: gamesUpdateManyWithWhereWithoutUsers_games_white_player_idTousersInput | gamesUpdateManyWithWhereWithoutUsers_games_white_player_idTousersInput[]
    deleteMany?: gamesScalarWhereInput | gamesScalarWhereInput[]
  }

  export type subscriptionsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput
    upsert?: subscriptionsUpsertWithoutUsersInput
    disconnect?: subscriptionsWhereInput | boolean
    delete?: subscriptionsWhereInput | boolean
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutUsersInput, subscriptionsUpdateWithoutUsersInput>, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput> | tournament_participantsCreateWithoutUsersInput[] | tournament_participantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournament_participantsCreateOrConnectWithoutUsersInput | tournament_participantsCreateOrConnectWithoutUsersInput[]
    upsert?: tournament_participantsUpsertWithWhereUniqueWithoutUsersInput | tournament_participantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tournament_participantsCreateManyUsersInputEnvelope
    set?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    disconnect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    delete?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    connect?: tournament_participantsWhereUniqueInput | tournament_participantsWhereUniqueInput[]
    update?: tournament_participantsUpdateWithWhereUniqueWithoutUsersInput | tournament_participantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tournament_participantsUpdateManyWithWhereWithoutUsersInput | tournament_participantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
  }

  export type tournamentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tournamentsCreateWithoutUsersInput, tournamentsUncheckedCreateWithoutUsersInput> | tournamentsCreateWithoutUsersInput[] | tournamentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tournamentsCreateOrConnectWithoutUsersInput | tournamentsCreateOrConnectWithoutUsersInput[]
    upsert?: tournamentsUpsertWithWhereUniqueWithoutUsersInput | tournamentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tournamentsCreateManyUsersInputEnvelope
    set?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    disconnect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    delete?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    connect?: tournamentsWhereUniqueInput | tournamentsWhereUniqueInput[]
    update?: tournamentsUpdateWithWhereUniqueWithoutUsersInput | tournamentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tournamentsUpdateManyWithWhereWithoutUsersInput | tournamentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
  }

  export type user_analyticsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput> | user_analyticsCreateWithoutUsersInput[] | user_analyticsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_analyticsCreateOrConnectWithoutUsersInput | user_analyticsCreateOrConnectWithoutUsersInput[]
    upsert?: user_analyticsUpsertWithWhereUniqueWithoutUsersInput | user_analyticsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_analyticsCreateManyUsersInputEnvelope
    set?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    disconnect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    delete?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    connect?: user_analyticsWhereUniqueInput | user_analyticsWhereUniqueInput[]
    update?: user_analyticsUpdateWithWhereUniqueWithoutUsersInput | user_analyticsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_analyticsUpdateManyWithWhereWithoutUsersInput | user_analyticsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<websocket_connectionsCreateWithoutUsersInput, websocket_connectionsUncheckedCreateWithoutUsersInput> | websocket_connectionsCreateWithoutUsersInput[] | websocket_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: websocket_connectionsCreateOrConnectWithoutUsersInput | websocket_connectionsCreateOrConnectWithoutUsersInput[]
    upsert?: websocket_connectionsUpsertWithWhereUniqueWithoutUsersInput | websocket_connectionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: websocket_connectionsCreateManyUsersInputEnvelope
    set?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    disconnect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    delete?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    connect?: websocket_connectionsWhereUniqueInput | websocket_connectionsWhereUniqueInput[]
    update?: websocket_connectionsUpdateWithWhereUniqueWithoutUsersInput | websocket_connectionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: websocket_connectionsUpdateManyWithWhereWithoutUsersInput | websocket_connectionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
  }

  export type gamesCreateNestedOneWithoutWebsocket_connectionsInput = {
    create?: XOR<gamesCreateWithoutWebsocket_connectionsInput, gamesUncheckedCreateWithoutWebsocket_connectionsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutWebsocket_connectionsInput
    connect?: gamesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutWebsocket_connectionsInput = {
    create?: XOR<usersCreateWithoutWebsocket_connectionsInput, usersUncheckedCreateWithoutWebsocket_connectionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWebsocket_connectionsInput
    connect?: usersWhereUniqueInput
  }

  export type gamesUpdateOneWithoutWebsocket_connectionsNestedInput = {
    create?: XOR<gamesCreateWithoutWebsocket_connectionsInput, gamesUncheckedCreateWithoutWebsocket_connectionsInput>
    connectOrCreate?: gamesCreateOrConnectWithoutWebsocket_connectionsInput
    upsert?: gamesUpsertWithoutWebsocket_connectionsInput
    disconnect?: gamesWhereInput | boolean
    delete?: gamesWhereInput | boolean
    connect?: gamesWhereUniqueInput
    update?: XOR<XOR<gamesUpdateToOneWithWhereWithoutWebsocket_connectionsInput, gamesUpdateWithoutWebsocket_connectionsInput>, gamesUncheckedUpdateWithoutWebsocket_connectionsInput>
  }

  export type usersUpdateOneRequiredWithoutWebsocket_connectionsNestedInput = {
    create?: XOR<usersCreateWithoutWebsocket_connectionsInput, usersUncheckedCreateWithoutWebsocket_connectionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWebsocket_connectionsInput
    upsert?: usersUpsertWithoutWebsocket_connectionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWebsocket_connectionsInput, usersUpdateWithoutWebsocket_connectionsInput>, usersUncheckedUpdateWithoutWebsocket_connectionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlayerFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerFilter<$PrismaModel> | $Enums.Player
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPlayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel>
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerWithAggregatesFilter<$PrismaModel> | $Enums.Player
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerFilter<$PrismaModel>
    _max?: NestedEnumPlayerFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type NestedEnumGameModeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeFilter<$PrismaModel> | $Enums.GameMode
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPlayerNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableFilter<$PrismaModel> | $Enums.Player | null
  }

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type NestedEnumGameModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameMode | EnumGameModeFieldRefInput<$PrismaModel>
    in?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameMode[] | ListEnumGameModeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameModeWithAggregatesFilter<$PrismaModel> | $Enums.GameMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameModeFilter<$PrismaModel>
    _max?: NestedEnumGameModeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlayerNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Player | EnumPlayerFieldRefInput<$PrismaModel> | null
    in?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Player[] | ListEnumPlayerFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlayerNullableWithAggregatesFilter<$PrismaModel> | $Enums.Player | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlayerNullableFilter<$PrismaModel>
    _max?: NestedEnumPlayerNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type NestedEnumLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelFilter<$PrismaModel> | $Enums.Level
  }

  export type NestedEnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type NestedEnumLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelWithAggregatesFilter<$PrismaModel> | $Enums.Level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelFilter<$PrismaModel>
    _max?: NestedEnumLevelFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type usersCreateWithoutAnalysesInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAnalysesInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAnalysesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
  }

  export type usersUpsertWithoutAnalysesInput = {
    update: XOR<usersUpdateWithoutAnalysesInput, usersUncheckedUpdateWithoutAnalysesInput>
    create: XOR<usersCreateWithoutAnalysesInput, usersUncheckedCreateWithoutAnalysesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAnalysesInput, usersUncheckedUpdateWithoutAnalysesInput>
  }

  export type usersUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type gamesCreateWithoutChat_messagesInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    game_moves?: game_movesCreateNestedManyWithoutGamesInput
    users_games_black_player_idTousers?: usersCreateNestedOneWithoutGames_games_black_player_idTousersInput
    tournaments?: tournamentsCreateNestedOneWithoutGamesInput
    users_games_white_player_idTousers?: usersCreateNestedOneWithoutGames_games_white_player_idTousersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutGamesInput
  }

  export type gamesUncheckedCreateWithoutChat_messagesInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
    game_moves?: game_movesUncheckedCreateNestedManyWithoutGamesInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesCreateOrConnectWithoutChat_messagesInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutChat_messagesInput, gamesUncheckedCreateWithoutChat_messagesInput>
  }

  export type usersCreateWithoutChat_messagesInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutChat_messagesInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutChat_messagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
  }

  export type gamesUpsertWithoutChat_messagesInput = {
    update: XOR<gamesUpdateWithoutChat_messagesInput, gamesUncheckedUpdateWithoutChat_messagesInput>
    create: XOR<gamesCreateWithoutChat_messagesInput, gamesUncheckedCreateWithoutChat_messagesInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutChat_messagesInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutChat_messagesInput, gamesUncheckedUpdateWithoutChat_messagesInput>
  }

  export type gamesUpdateWithoutChat_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    game_moves?: game_movesUpdateManyWithoutGamesNestedInput
    users_games_black_player_idTousers?: usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput
    tournaments?: tournamentsUpdateOneWithoutGamesNestedInput
    users_games_white_player_idTousers?: usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateWithoutChat_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
    game_moves?: game_movesUncheckedUpdateManyWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type usersUpsertWithoutChat_messagesInput = {
    update: XOR<usersUpdateWithoutChat_messagesInput, usersUncheckedUpdateWithoutChat_messagesInput>
    create: XOR<usersCreateWithoutChat_messagesInput, usersUncheckedCreateWithoutChat_messagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChat_messagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChat_messagesInput, usersUncheckedUpdateWithoutChat_messagesInput>
  }

  export type usersUpdateWithoutChat_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutChat_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type gamesCreateWithoutGame_movesInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesCreateNestedManyWithoutGamesInput
    users_games_black_player_idTousers?: usersCreateNestedOneWithoutGames_games_black_player_idTousersInput
    tournaments?: tournamentsCreateNestedOneWithoutGamesInput
    users_games_white_player_idTousers?: usersCreateNestedOneWithoutGames_games_white_player_idTousersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutGamesInput
  }

  export type gamesUncheckedCreateWithoutGame_movesInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutGamesInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesCreateOrConnectWithoutGame_movesInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutGame_movesInput, gamesUncheckedCreateWithoutGame_movesInput>
  }

  export type usersCreateWithoutGame_movesInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutGame_movesInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutGame_movesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGame_movesInput, usersUncheckedCreateWithoutGame_movesInput>
  }

  export type gamesUpsertWithoutGame_movesInput = {
    update: XOR<gamesUpdateWithoutGame_movesInput, gamesUncheckedUpdateWithoutGame_movesInput>
    create: XOR<gamesCreateWithoutGame_movesInput, gamesUncheckedCreateWithoutGame_movesInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutGame_movesInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutGame_movesInput, gamesUncheckedUpdateWithoutGame_movesInput>
  }

  export type gamesUpdateWithoutGame_movesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUpdateManyWithoutGamesNestedInput
    users_games_black_player_idTousers?: usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput
    tournaments?: tournamentsUpdateOneWithoutGamesNestedInput
    users_games_white_player_idTousers?: usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateWithoutGame_movesInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type usersUpsertWithoutGame_movesInput = {
    update: XOR<usersUpdateWithoutGame_movesInput, usersUncheckedUpdateWithoutGame_movesInput>
    create: XOR<usersCreateWithoutGame_movesInput, usersUncheckedCreateWithoutGame_movesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGame_movesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGame_movesInput, usersUncheckedUpdateWithoutGame_movesInput>
  }

  export type usersUpdateWithoutGame_movesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutGame_movesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type chat_messagesCreateWithoutGamesInput = {
    id: string
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
    users?: usersCreateNestedOneWithoutChat_messagesInput
  }

  export type chat_messagesUncheckedCreateWithoutGamesInput = {
    id: string
    user_id?: string | null
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesCreateOrConnectWithoutGamesInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutGamesInput, chat_messagesUncheckedCreateWithoutGamesInput>
  }

  export type chat_messagesCreateManyGamesInputEnvelope = {
    data: chat_messagesCreateManyGamesInput | chat_messagesCreateManyGamesInput[]
    skipDuplicates?: boolean
  }

  export type game_movesCreateWithoutGamesInput = {
    id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
    users?: usersCreateNestedOneWithoutGame_movesInput
  }

  export type game_movesUncheckedCreateWithoutGamesInput = {
    id: string
    user_id?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
  }

  export type game_movesCreateOrConnectWithoutGamesInput = {
    where: game_movesWhereUniqueInput
    create: XOR<game_movesCreateWithoutGamesInput, game_movesUncheckedCreateWithoutGamesInput>
  }

  export type game_movesCreateManyGamesInputEnvelope = {
    data: game_movesCreateManyGamesInput | game_movesCreateManyGamesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutGames_games_black_player_idTousersInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutGames_games_black_player_idTousersInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutGames_games_black_player_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGames_games_black_player_idTousersInput, usersUncheckedCreateWithoutGames_games_black_player_idTousersInput>
  }

  export type tournamentsCreateWithoutGamesInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    createdAt?: Date | string
    tournament_participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
    users: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateWithoutGamesInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    created_by: string
    createdAt?: Date | string
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
  }

  export type tournamentsCreateOrConnectWithoutGamesInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
  }

  export type usersCreateWithoutGames_games_white_player_idTousersInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutGames_games_white_player_idTousersInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutGames_games_white_player_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGames_games_white_player_idTousersInput, usersUncheckedCreateWithoutGames_games_white_player_idTousersInput>
  }

  export type websocket_connectionsCreateWithoutGamesInput = {
    id: string
    connection_id: string
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
    users: usersCreateNestedOneWithoutWebsocket_connectionsInput
  }

  export type websocket_connectionsUncheckedCreateWithoutGamesInput = {
    id: string
    connection_id: string
    user_id: string
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
  }

  export type websocket_connectionsCreateOrConnectWithoutGamesInput = {
    where: websocket_connectionsWhereUniqueInput
    create: XOR<websocket_connectionsCreateWithoutGamesInput, websocket_connectionsUncheckedCreateWithoutGamesInput>
  }

  export type websocket_connectionsCreateManyGamesInputEnvelope = {
    data: websocket_connectionsCreateManyGamesInput | websocket_connectionsCreateManyGamesInput[]
    skipDuplicates?: boolean
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutGamesInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutGamesInput, chat_messagesUncheckedUpdateWithoutGamesInput>
    create: XOR<chat_messagesCreateWithoutGamesInput, chat_messagesUncheckedCreateWithoutGamesInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutGamesInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutGamesInput, chat_messagesUncheckedUpdateWithoutGamesInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutGamesInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutGamesInput>
  }

  export type chat_messagesScalarWhereInput = {
    AND?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    OR?: chat_messagesScalarWhereInput[]
    NOT?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    id?: StringFilter<"chat_messages"> | string
    game_id?: StringFilter<"chat_messages"> | string
    user_id?: StringNullableFilter<"chat_messages"> | string | null
    message?: StringFilter<"chat_messages"> | string
    message_type?: EnumMessageTypeFilter<"chat_messages"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"chat_messages"> | Date | string
  }

  export type game_movesUpsertWithWhereUniqueWithoutGamesInput = {
    where: game_movesWhereUniqueInput
    update: XOR<game_movesUpdateWithoutGamesInput, game_movesUncheckedUpdateWithoutGamesInput>
    create: XOR<game_movesCreateWithoutGamesInput, game_movesUncheckedCreateWithoutGamesInput>
  }

  export type game_movesUpdateWithWhereUniqueWithoutGamesInput = {
    where: game_movesWhereUniqueInput
    data: XOR<game_movesUpdateWithoutGamesInput, game_movesUncheckedUpdateWithoutGamesInput>
  }

  export type game_movesUpdateManyWithWhereWithoutGamesInput = {
    where: game_movesScalarWhereInput
    data: XOR<game_movesUpdateManyMutationInput, game_movesUncheckedUpdateManyWithoutGamesInput>
  }

  export type game_movesScalarWhereInput = {
    AND?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
    OR?: game_movesScalarWhereInput[]
    NOT?: game_movesScalarWhereInput | game_movesScalarWhereInput[]
    id?: StringFilter<"game_moves"> | string
    game_id?: StringFilter<"game_moves"> | string
    user_id?: StringNullableFilter<"game_moves"> | string | null
    player?: EnumPlayerFilter<"game_moves"> | $Enums.Player
    dice?: IntNullableListFilter<"game_moves">
    move?: StringFilter<"game_moves"> | string
    from_point?: IntNullableFilter<"game_moves"> | number | null
    to_point?: IntNullableFilter<"game_moves"> | number | null
    equity?: FloatNullableFilter<"game_moves"> | number | null
    pr?: FloatNullableFilter<"game_moves"> | number | null
    thinking_time?: IntNullableFilter<"game_moves"> | number | null
    createdAt?: DateTimeFilter<"game_moves"> | Date | string
  }

  export type usersUpsertWithoutGames_games_black_player_idTousersInput = {
    update: XOR<usersUpdateWithoutGames_games_black_player_idTousersInput, usersUncheckedUpdateWithoutGames_games_black_player_idTousersInput>
    create: XOR<usersCreateWithoutGames_games_black_player_idTousersInput, usersUncheckedCreateWithoutGames_games_black_player_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGames_games_black_player_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGames_games_black_player_idTousersInput, usersUncheckedUpdateWithoutGames_games_black_player_idTousersInput>
  }

  export type usersUpdateWithoutGames_games_black_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutGames_games_black_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tournamentsUpsertWithoutGamesInput = {
    update: XOR<tournamentsUpdateWithoutGamesInput, tournamentsUncheckedUpdateWithoutGamesInput>
    create: XOR<tournamentsCreateWithoutGamesInput, tournamentsUncheckedCreateWithoutGamesInput>
    where?: tournamentsWhereInput
  }

  export type tournamentsUpdateToOneWithWhereWithoutGamesInput = {
    where?: tournamentsWhereInput
    data: XOR<tournamentsUpdateWithoutGamesInput, tournamentsUncheckedUpdateWithoutGamesInput>
  }

  export type tournamentsUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament_participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
  }

  export type usersUpsertWithoutGames_games_white_player_idTousersInput = {
    update: XOR<usersUpdateWithoutGames_games_white_player_idTousersInput, usersUncheckedUpdateWithoutGames_games_white_player_idTousersInput>
    create: XOR<usersCreateWithoutGames_games_white_player_idTousersInput, usersUncheckedCreateWithoutGames_games_white_player_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGames_games_white_player_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGames_games_white_player_idTousersInput, usersUncheckedUpdateWithoutGames_games_white_player_idTousersInput>
  }

  export type usersUpdateWithoutGames_games_white_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutGames_games_white_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type websocket_connectionsUpsertWithWhereUniqueWithoutGamesInput = {
    where: websocket_connectionsWhereUniqueInput
    update: XOR<websocket_connectionsUpdateWithoutGamesInput, websocket_connectionsUncheckedUpdateWithoutGamesInput>
    create: XOR<websocket_connectionsCreateWithoutGamesInput, websocket_connectionsUncheckedCreateWithoutGamesInput>
  }

  export type websocket_connectionsUpdateWithWhereUniqueWithoutGamesInput = {
    where: websocket_connectionsWhereUniqueInput
    data: XOR<websocket_connectionsUpdateWithoutGamesInput, websocket_connectionsUncheckedUpdateWithoutGamesInput>
  }

  export type websocket_connectionsUpdateManyWithWhereWithoutGamesInput = {
    where: websocket_connectionsScalarWhereInput
    data: XOR<websocket_connectionsUpdateManyMutationInput, websocket_connectionsUncheckedUpdateManyWithoutGamesInput>
  }

  export type websocket_connectionsScalarWhereInput = {
    AND?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
    OR?: websocket_connectionsScalarWhereInput[]
    NOT?: websocket_connectionsScalarWhereInput | websocket_connectionsScalarWhereInput[]
    id?: StringFilter<"websocket_connections"> | string
    connection_id?: StringFilter<"websocket_connections"> | string
    user_id?: StringFilter<"websocket_connections"> | string
    game_id?: StringNullableFilter<"websocket_connections"> | string | null
    connected_at?: DateTimeFilter<"websocket_connections"> | Date | string
    last_ping?: DateTimeFilter<"websocket_connections"> | Date | string
    is_active?: BoolFilter<"websocket_connections"> | boolean
  }

  export type usersCreateWithoutSubscriptionsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSubscriptionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
  }

  export type usersUpsertWithoutSubscriptionsInput = {
    update: XOR<usersUpdateWithoutSubscriptionsInput, usersUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSubscriptionsInput, usersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type usersUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tournamentsCreateWithoutTournament_participantsInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentsInput
    users: usersCreateNestedOneWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateWithoutTournament_participantsInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    created_by: string
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentsInput
  }

  export type tournamentsCreateOrConnectWithoutTournament_participantsInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutTournament_participantsInput, tournamentsUncheckedCreateWithoutTournament_participantsInput>
  }

  export type usersCreateWithoutTournament_participantsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTournament_participantsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTournament_participantsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTournament_participantsInput, usersUncheckedCreateWithoutTournament_participantsInput>
  }

  export type tournamentsUpsertWithoutTournament_participantsInput = {
    update: XOR<tournamentsUpdateWithoutTournament_participantsInput, tournamentsUncheckedUpdateWithoutTournament_participantsInput>
    create: XOR<tournamentsCreateWithoutTournament_participantsInput, tournamentsUncheckedCreateWithoutTournament_participantsInput>
    where?: tournamentsWhereInput
  }

  export type tournamentsUpdateToOneWithWhereWithoutTournament_participantsInput = {
    where?: tournamentsWhereInput
    data: XOR<tournamentsUpdateWithoutTournament_participantsInput, tournamentsUncheckedUpdateWithoutTournament_participantsInput>
  }

  export type tournamentsUpdateWithoutTournament_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentsNestedInput
    users?: usersUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutTournament_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentsNestedInput
  }

  export type usersUpsertWithoutTournament_participantsInput = {
    update: XOR<usersUpdateWithoutTournament_participantsInput, usersUncheckedUpdateWithoutTournament_participantsInput>
    create: XOR<usersCreateWithoutTournament_participantsInput, usersUncheckedCreateWithoutTournament_participantsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTournament_participantsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTournament_participantsInput, usersUncheckedUpdateWithoutTournament_participantsInput>
  }

  export type usersUpdateWithoutTournament_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTournament_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type gamesCreateWithoutTournamentsInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesCreateNestedManyWithoutGamesInput
    game_moves?: game_movesCreateNestedManyWithoutGamesInput
    users_games_black_player_idTousers?: usersCreateNestedOneWithoutGames_games_black_player_idTousersInput
    users_games_white_player_idTousers?: usersCreateNestedOneWithoutGames_games_white_player_idTousersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutGamesInput
  }

  export type gamesUncheckedCreateWithoutTournamentsInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutGamesInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutGamesInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesCreateOrConnectWithoutTournamentsInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutTournamentsInput, gamesUncheckedCreateWithoutTournamentsInput>
  }

  export type gamesCreateManyTournamentsInputEnvelope = {
    data: gamesCreateManyTournamentsInput | gamesCreateManyTournamentsInput[]
    skipDuplicates?: boolean
  }

  export type tournament_participantsCreateWithoutTournamentsInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    users: usersCreateNestedOneWithoutTournament_participantsInput
  }

  export type tournament_participantsUncheckedCreateWithoutTournamentsInput = {
    id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournament_participantsCreateOrConnectWithoutTournamentsInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput>
  }

  export type tournament_participantsCreateManyTournamentsInputEnvelope = {
    data: tournament_participantsCreateManyTournamentsInput | tournament_participantsCreateManyTournamentsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTournamentsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTournamentsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTournamentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
  }

  export type gamesUpsertWithWhereUniqueWithoutTournamentsInput = {
    where: gamesWhereUniqueInput
    update: XOR<gamesUpdateWithoutTournamentsInput, gamesUncheckedUpdateWithoutTournamentsInput>
    create: XOR<gamesCreateWithoutTournamentsInput, gamesUncheckedCreateWithoutTournamentsInput>
  }

  export type gamesUpdateWithWhereUniqueWithoutTournamentsInput = {
    where: gamesWhereUniqueInput
    data: XOR<gamesUpdateWithoutTournamentsInput, gamesUncheckedUpdateWithoutTournamentsInput>
  }

  export type gamesUpdateManyWithWhereWithoutTournamentsInput = {
    where: gamesScalarWhereInput
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyWithoutTournamentsInput>
  }

  export type gamesScalarWhereInput = {
    AND?: gamesScalarWhereInput | gamesScalarWhereInput[]
    OR?: gamesScalarWhereInput[]
    NOT?: gamesScalarWhereInput | gamesScalarWhereInput[]
    id?: StringFilter<"games"> | string
    white_player_id?: StringNullableFilter<"games"> | string | null
    black_player_id?: StringNullableFilter<"games"> | string | null
    status?: EnumGameStatusFilter<"games"> | $Enums.GameStatus
    board_state?: StringFilter<"games"> | string
    gameMode?: EnumGameModeFilter<"games"> | $Enums.GameMode
    current_player?: EnumPlayerFilter<"games"> | $Enums.Player
    dice?: IntNullableListFilter<"games">
    white_score?: IntFilter<"games"> | number
    black_score?: IntFilter<"games"> | number
    createdAt?: DateTimeFilter<"games"> | Date | string
    finished_at?: DateTimeNullableFilter<"games"> | Date | string | null
    winner?: EnumPlayerNullableFilter<"games"> | $Enums.Player | null
    tournament_id?: StringNullableFilter<"games"> | string | null
  }

  export type tournament_participantsUpsertWithWhereUniqueWithoutTournamentsInput = {
    where: tournament_participantsWhereUniqueInput
    update: XOR<tournament_participantsUpdateWithoutTournamentsInput, tournament_participantsUncheckedUpdateWithoutTournamentsInput>
    create: XOR<tournament_participantsCreateWithoutTournamentsInput, tournament_participantsUncheckedCreateWithoutTournamentsInput>
  }

  export type tournament_participantsUpdateWithWhereUniqueWithoutTournamentsInput = {
    where: tournament_participantsWhereUniqueInput
    data: XOR<tournament_participantsUpdateWithoutTournamentsInput, tournament_participantsUncheckedUpdateWithoutTournamentsInput>
  }

  export type tournament_participantsUpdateManyWithWhereWithoutTournamentsInput = {
    where: tournament_participantsScalarWhereInput
    data: XOR<tournament_participantsUpdateManyMutationInput, tournament_participantsUncheckedUpdateManyWithoutTournamentsInput>
  }

  export type tournament_participantsScalarWhereInput = {
    AND?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
    OR?: tournament_participantsScalarWhereInput[]
    NOT?: tournament_participantsScalarWhereInput | tournament_participantsScalarWhereInput[]
    id?: StringFilter<"tournament_participants"> | string
    tournament_id?: StringFilter<"tournament_participants"> | string
    user_id?: StringFilter<"tournament_participants"> | string
    registered_at?: DateTimeFilter<"tournament_participants"> | Date | string
    current_position?: IntNullableFilter<"tournament_participants"> | number | null
    eliminated_at?: DateTimeNullableFilter<"tournament_participants"> | Date | string | null
  }

  export type usersUpsertWithoutTournamentsInput = {
    update: XOR<usersUpdateWithoutTournamentsInput, usersUncheckedUpdateWithoutTournamentsInput>
    create: XOR<usersCreateWithoutTournamentsInput, usersUncheckedCreateWithoutTournamentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTournamentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTournamentsInput, usersUncheckedUpdateWithoutTournamentsInput>
  }

  export type usersUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_analyticsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_analyticsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_analyticsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
  }

  export type usersUpsertWithoutUser_analyticsInput = {
    update: XOR<usersUpdateWithoutUser_analyticsInput, usersUncheckedUpdateWithoutUser_analyticsInput>
    create: XOR<usersCreateWithoutUser_analyticsInput, usersUncheckedCreateWithoutUser_analyticsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_analyticsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_analyticsInput, usersUncheckedUpdateWithoutUser_analyticsInput>
  }

  export type usersUpdateWithoutUser_analyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_analyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type analysesCreateWithoutUsersInput = {
    id: string
    board_state: string
    dice?: analysesCreatediceInput | number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesUncheckedCreateWithoutUsersInput = {
    id: string
    board_state: string
    dice?: analysesCreatediceInput | number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type analysesCreateOrConnectWithoutUsersInput = {
    where: analysesWhereUniqueInput
    create: XOR<analysesCreateWithoutUsersInput, analysesUncheckedCreateWithoutUsersInput>
  }

  export type analysesCreateManyUsersInputEnvelope = {
    data: analysesCreateManyUsersInput | analysesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type chat_messagesCreateWithoutUsersInput = {
    id: string
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
    games: gamesCreateNestedOneWithoutChat_messagesInput
  }

  export type chat_messagesUncheckedCreateWithoutUsersInput = {
    id: string
    game_id: string
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type chat_messagesCreateOrConnectWithoutUsersInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput>
  }

  export type chat_messagesCreateManyUsersInputEnvelope = {
    data: chat_messagesCreateManyUsersInput | chat_messagesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type game_movesCreateWithoutUsersInput = {
    id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
    games: gamesCreateNestedOneWithoutGame_movesInput
  }

  export type game_movesUncheckedCreateWithoutUsersInput = {
    id: string
    game_id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
  }

  export type game_movesCreateOrConnectWithoutUsersInput = {
    where: game_movesWhereUniqueInput
    create: XOR<game_movesCreateWithoutUsersInput, game_movesUncheckedCreateWithoutUsersInput>
  }

  export type game_movesCreateManyUsersInputEnvelope = {
    data: game_movesCreateManyUsersInput | game_movesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type gamesCreateWithoutUsers_games_black_player_idTousersInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesCreateNestedManyWithoutGamesInput
    game_moves?: game_movesCreateNestedManyWithoutGamesInput
    tournaments?: tournamentsCreateNestedOneWithoutGamesInput
    users_games_white_player_idTousers?: usersCreateNestedOneWithoutGames_games_white_player_idTousersInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutGamesInput
  }

  export type gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput = {
    id: string
    white_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutGamesInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutGamesInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesCreateOrConnectWithoutUsers_games_black_player_idTousersInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput>
  }

  export type gamesCreateManyUsers_games_black_player_idTousersInputEnvelope = {
    data: gamesCreateManyUsers_games_black_player_idTousersInput | gamesCreateManyUsers_games_black_player_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type gamesCreateWithoutUsers_games_white_player_idTousersInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesCreateNestedManyWithoutGamesInput
    game_moves?: game_movesCreateNestedManyWithoutGamesInput
    users_games_black_player_idTousers?: usersCreateNestedOneWithoutGames_games_black_player_idTousersInput
    tournaments?: tournamentsCreateNestedOneWithoutGamesInput
    websocket_connections?: websocket_connectionsCreateNestedManyWithoutGamesInput
  }

  export type gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput = {
    id: string
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutGamesInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutGamesInput
    websocket_connections?: websocket_connectionsUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesCreateOrConnectWithoutUsers_games_white_player_idTousersInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput>
  }

  export type gamesCreateManyUsers_games_white_player_idTousersInputEnvelope = {
    data: gamesCreateManyUsers_games_white_player_idTousersInput | gamesCreateManyUsers_games_white_player_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionsCreateWithoutUsersInput = {
    id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUncheckedCreateWithoutUsersInput = {
    id: string
    stripe_subscription_id?: string | null
    stripe_customer_id?: string | null
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    current_period_start?: Date | string | null
    current_period_end?: Date | string | null
    cancel_at_period_end?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsCreateOrConnectWithoutUsersInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type tournament_participantsCreateWithoutUsersInput = {
    id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
    tournaments: tournamentsCreateNestedOneWithoutTournament_participantsInput
  }

  export type tournament_participantsUncheckedCreateWithoutUsersInput = {
    id: string
    tournament_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournament_participantsCreateOrConnectWithoutUsersInput = {
    where: tournament_participantsWhereUniqueInput
    create: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput>
  }

  export type tournament_participantsCreateManyUsersInputEnvelope = {
    data: tournament_participantsCreateManyUsersInput | tournament_participantsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type tournamentsCreateWithoutUsersInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    createdAt?: Date | string
    games?: gamesCreateNestedManyWithoutTournamentsInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutTournamentsInput
  }

  export type tournamentsUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    createdAt?: Date | string
    games?: gamesUncheckedCreateNestedManyWithoutTournamentsInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutTournamentsInput
  }

  export type tournamentsCreateOrConnectWithoutUsersInput = {
    where: tournamentsWhereUniqueInput
    create: XOR<tournamentsCreateWithoutUsersInput, tournamentsUncheckedCreateWithoutUsersInput>
  }

  export type tournamentsCreateManyUsersInputEnvelope = {
    data: tournamentsCreateManyUsersInput | tournamentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_analyticsCreateWithoutUsersInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    createdAt?: Date | string
  }

  export type user_analyticsUncheckedCreateWithoutUsersInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    createdAt?: Date | string
  }

  export type user_analyticsCreateOrConnectWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    create: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
  }

  export type user_analyticsCreateManyUsersInputEnvelope = {
    data: user_analyticsCreateManyUsersInput | user_analyticsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type websocket_connectionsCreateWithoutUsersInput = {
    id: string
    connection_id: string
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
    games?: gamesCreateNestedOneWithoutWebsocket_connectionsInput
  }

  export type websocket_connectionsUncheckedCreateWithoutUsersInput = {
    id: string
    connection_id: string
    game_id?: string | null
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
  }

  export type websocket_connectionsCreateOrConnectWithoutUsersInput = {
    where: websocket_connectionsWhereUniqueInput
    create: XOR<websocket_connectionsCreateWithoutUsersInput, websocket_connectionsUncheckedCreateWithoutUsersInput>
  }

  export type websocket_connectionsCreateManyUsersInputEnvelope = {
    data: websocket_connectionsCreateManyUsersInput | websocket_connectionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type analysesUpsertWithWhereUniqueWithoutUsersInput = {
    where: analysesWhereUniqueInput
    update: XOR<analysesUpdateWithoutUsersInput, analysesUncheckedUpdateWithoutUsersInput>
    create: XOR<analysesCreateWithoutUsersInput, analysesUncheckedCreateWithoutUsersInput>
  }

  export type analysesUpdateWithWhereUniqueWithoutUsersInput = {
    where: analysesWhereUniqueInput
    data: XOR<analysesUpdateWithoutUsersInput, analysesUncheckedUpdateWithoutUsersInput>
  }

  export type analysesUpdateManyWithWhereWithoutUsersInput = {
    where: analysesScalarWhereInput
    data: XOR<analysesUpdateManyMutationInput, analysesUncheckedUpdateManyWithoutUsersInput>
  }

  export type analysesScalarWhereInput = {
    AND?: analysesScalarWhereInput | analysesScalarWhereInput[]
    OR?: analysesScalarWhereInput[]
    NOT?: analysesScalarWhereInput | analysesScalarWhereInput[]
    id?: StringFilter<"analyses"> | string
    user_id?: StringFilter<"analyses"> | string
    board_state?: StringFilter<"analyses"> | string
    dice?: IntNullableListFilter<"analyses">
    move?: StringFilter<"analyses"> | string
    best_move?: StringFilter<"analyses"> | string
    equity?: FloatFilter<"analyses"> | number
    pr?: FloatFilter<"analyses"> | number
    explanation?: StringFilter<"analyses"> | string
    alternatives?: JsonFilter<"analyses">
    analysis_type?: EnumAnalysisTypeFilter<"analyses"> | $Enums.AnalysisType
    createdAt?: DateTimeFilter<"analyses"> | Date | string
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutUsersInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutUsersInput, chat_messagesUncheckedUpdateWithoutUsersInput>
    create: XOR<chat_messagesCreateWithoutUsersInput, chat_messagesUncheckedCreateWithoutUsersInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutUsersInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutUsersInput, chat_messagesUncheckedUpdateWithoutUsersInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutUsersInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutUsersInput>
  }

  export type game_movesUpsertWithWhereUniqueWithoutUsersInput = {
    where: game_movesWhereUniqueInput
    update: XOR<game_movesUpdateWithoutUsersInput, game_movesUncheckedUpdateWithoutUsersInput>
    create: XOR<game_movesCreateWithoutUsersInput, game_movesUncheckedCreateWithoutUsersInput>
  }

  export type game_movesUpdateWithWhereUniqueWithoutUsersInput = {
    where: game_movesWhereUniqueInput
    data: XOR<game_movesUpdateWithoutUsersInput, game_movesUncheckedUpdateWithoutUsersInput>
  }

  export type game_movesUpdateManyWithWhereWithoutUsersInput = {
    where: game_movesScalarWhereInput
    data: XOR<game_movesUpdateManyMutationInput, game_movesUncheckedUpdateManyWithoutUsersInput>
  }

  export type gamesUpsertWithWhereUniqueWithoutUsers_games_black_player_idTousersInput = {
    where: gamesWhereUniqueInput
    update: XOR<gamesUpdateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedUpdateWithoutUsers_games_black_player_idTousersInput>
    create: XOR<gamesCreateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_black_player_idTousersInput>
  }

  export type gamesUpdateWithWhereUniqueWithoutUsers_games_black_player_idTousersInput = {
    where: gamesWhereUniqueInput
    data: XOR<gamesUpdateWithoutUsers_games_black_player_idTousersInput, gamesUncheckedUpdateWithoutUsers_games_black_player_idTousersInput>
  }

  export type gamesUpdateManyWithWhereWithoutUsers_games_black_player_idTousersInput = {
    where: gamesScalarWhereInput
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersInput>
  }

  export type gamesUpsertWithWhereUniqueWithoutUsers_games_white_player_idTousersInput = {
    where: gamesWhereUniqueInput
    update: XOR<gamesUpdateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedUpdateWithoutUsers_games_white_player_idTousersInput>
    create: XOR<gamesCreateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedCreateWithoutUsers_games_white_player_idTousersInput>
  }

  export type gamesUpdateWithWhereUniqueWithoutUsers_games_white_player_idTousersInput = {
    where: gamesWhereUniqueInput
    data: XOR<gamesUpdateWithoutUsers_games_white_player_idTousersInput, gamesUncheckedUpdateWithoutUsers_games_white_player_idTousersInput>
  }

  export type gamesUpdateManyWithWhereWithoutUsers_games_white_player_idTousersInput = {
    where: gamesScalarWhereInput
    data: XOR<gamesUpdateManyMutationInput, gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersInput>
  }

  export type subscriptionsUpsertWithoutUsersInput = {
    update: XOR<subscriptionsUpdateWithoutUsersInput, subscriptionsUncheckedUpdateWithoutUsersInput>
    create: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
    where?: subscriptionsWhereInput
  }

  export type subscriptionsUpdateToOneWithWhereWithoutUsersInput = {
    where?: subscriptionsWhereInput
    data: XOR<subscriptionsUpdateWithoutUsersInput, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type subscriptionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    current_period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournament_participantsUpsertWithWhereUniqueWithoutUsersInput = {
    where: tournament_participantsWhereUniqueInput
    update: XOR<tournament_participantsUpdateWithoutUsersInput, tournament_participantsUncheckedUpdateWithoutUsersInput>
    create: XOR<tournament_participantsCreateWithoutUsersInput, tournament_participantsUncheckedCreateWithoutUsersInput>
  }

  export type tournament_participantsUpdateWithWhereUniqueWithoutUsersInput = {
    where: tournament_participantsWhereUniqueInput
    data: XOR<tournament_participantsUpdateWithoutUsersInput, tournament_participantsUncheckedUpdateWithoutUsersInput>
  }

  export type tournament_participantsUpdateManyWithWhereWithoutUsersInput = {
    where: tournament_participantsScalarWhereInput
    data: XOR<tournament_participantsUpdateManyMutationInput, tournament_participantsUncheckedUpdateManyWithoutUsersInput>
  }

  export type tournamentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: tournamentsWhereUniqueInput
    update: XOR<tournamentsUpdateWithoutUsersInput, tournamentsUncheckedUpdateWithoutUsersInput>
    create: XOR<tournamentsCreateWithoutUsersInput, tournamentsUncheckedCreateWithoutUsersInput>
  }

  export type tournamentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: tournamentsWhereUniqueInput
    data: XOR<tournamentsUpdateWithoutUsersInput, tournamentsUncheckedUpdateWithoutUsersInput>
  }

  export type tournamentsUpdateManyWithWhereWithoutUsersInput = {
    where: tournamentsScalarWhereInput
    data: XOR<tournamentsUpdateManyMutationInput, tournamentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type tournamentsScalarWhereInput = {
    AND?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
    OR?: tournamentsScalarWhereInput[]
    NOT?: tournamentsScalarWhereInput | tournamentsScalarWhereInput[]
    id?: StringFilter<"tournaments"> | string
    name?: StringFilter<"tournaments"> | string
    description?: StringNullableFilter<"tournaments"> | string | null
    entryFee?: IntFilter<"tournaments"> | number
    prizePool?: IntFilter<"tournaments"> | number
    maxPlayers?: IntNullableFilter<"tournaments"> | number | null
    status?: EnumTournamentStatusFilter<"tournaments"> | $Enums.TournamentStatus
    start_time?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    end_time?: DateTimeNullableFilter<"tournaments"> | Date | string | null
    created_by?: StringFilter<"tournaments"> | string
    createdAt?: DateTimeFilter<"tournaments"> | Date | string
  }

  export type user_analyticsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    update: XOR<user_analyticsUpdateWithoutUsersInput, user_analyticsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_analyticsCreateWithoutUsersInput, user_analyticsUncheckedCreateWithoutUsersInput>
  }

  export type user_analyticsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_analyticsWhereUniqueInput
    data: XOR<user_analyticsUpdateWithoutUsersInput, user_analyticsUncheckedUpdateWithoutUsersInput>
  }

  export type user_analyticsUpdateManyWithWhereWithoutUsersInput = {
    where: user_analyticsScalarWhereInput
    data: XOR<user_analyticsUpdateManyMutationInput, user_analyticsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_analyticsScalarWhereInput = {
    AND?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
    OR?: user_analyticsScalarWhereInput[]
    NOT?: user_analyticsScalarWhereInput | user_analyticsScalarWhereInput[]
    id?: StringFilter<"user_analytics"> | string
    user_id?: StringFilter<"user_analytics"> | string
    date?: DateTimeFilter<"user_analytics"> | Date | string
    games_played?: IntFilter<"user_analytics"> | number
    games_won?: IntFilter<"user_analytics"> | number
    analyses_completed?: IntFilter<"user_analytics"> | number
    time_played?: IntFilter<"user_analytics"> | number
    avg_equity?: FloatFilter<"user_analytics"> | number
    elo_change?: IntFilter<"user_analytics"> | number
    createdAt?: DateTimeFilter<"user_analytics"> | Date | string
  }

  export type websocket_connectionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: websocket_connectionsWhereUniqueInput
    update: XOR<websocket_connectionsUpdateWithoutUsersInput, websocket_connectionsUncheckedUpdateWithoutUsersInput>
    create: XOR<websocket_connectionsCreateWithoutUsersInput, websocket_connectionsUncheckedCreateWithoutUsersInput>
  }

  export type websocket_connectionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: websocket_connectionsWhereUniqueInput
    data: XOR<websocket_connectionsUpdateWithoutUsersInput, websocket_connectionsUncheckedUpdateWithoutUsersInput>
  }

  export type websocket_connectionsUpdateManyWithWhereWithoutUsersInput = {
    where: websocket_connectionsScalarWhereInput
    data: XOR<websocket_connectionsUpdateManyMutationInput, websocket_connectionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type gamesCreateWithoutWebsocket_connectionsInput = {
    id: string
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    chat_messages?: chat_messagesCreateNestedManyWithoutGamesInput
    game_moves?: game_movesCreateNestedManyWithoutGamesInput
    users_games_black_player_idTousers?: usersCreateNestedOneWithoutGames_games_black_player_idTousersInput
    tournaments?: tournamentsCreateNestedOneWithoutGamesInput
    users_games_white_player_idTousers?: usersCreateNestedOneWithoutGames_games_white_player_idTousersInput
  }

  export type gamesUncheckedCreateWithoutWebsocket_connectionsInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutGamesInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutGamesInput
  }

  export type gamesCreateOrConnectWithoutWebsocket_connectionsInput = {
    where: gamesWhereUniqueInput
    create: XOR<gamesCreateWithoutWebsocket_connectionsInput, gamesUncheckedCreateWithoutWebsocket_connectionsInput>
  }

  export type usersCreateWithoutWebsocket_connectionsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesCreateNestedManyWithoutUsersInput
    game_moves?: game_movesCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutWebsocket_connectionsInput = {
    id: string
    email: string
    password: string
    username: string
    avatar?: string | null
    level?: $Enums.Level
    elo?: number
    subscriptionType?: $Enums.SubscriptionType
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    lastLoginAt?: Date | string
    analyses?: analysesUncheckedCreateNestedManyWithoutUsersInput
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutUsersInput
    game_moves?: game_movesUncheckedCreateNestedManyWithoutUsersInput
    games_games_black_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_black_player_idTousersInput
    games_games_white_player_idTousers?: gamesUncheckedCreateNestedManyWithoutUsers_games_white_player_idTousersInput
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutUsersInput
    tournament_participants?: tournament_participantsUncheckedCreateNestedManyWithoutUsersInput
    tournaments?: tournamentsUncheckedCreateNestedManyWithoutUsersInput
    user_analytics?: user_analyticsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutWebsocket_connectionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWebsocket_connectionsInput, usersUncheckedCreateWithoutWebsocket_connectionsInput>
  }

  export type gamesUpsertWithoutWebsocket_connectionsInput = {
    update: XOR<gamesUpdateWithoutWebsocket_connectionsInput, gamesUncheckedUpdateWithoutWebsocket_connectionsInput>
    create: XOR<gamesCreateWithoutWebsocket_connectionsInput, gamesUncheckedCreateWithoutWebsocket_connectionsInput>
    where?: gamesWhereInput
  }

  export type gamesUpdateToOneWithWhereWithoutWebsocket_connectionsInput = {
    where?: gamesWhereInput
    data: XOR<gamesUpdateWithoutWebsocket_connectionsInput, gamesUncheckedUpdateWithoutWebsocket_connectionsInput>
  }

  export type gamesUpdateWithoutWebsocket_connectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUpdateManyWithoutGamesNestedInput
    users_games_black_player_idTousers?: usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput
    tournaments?: tournamentsUpdateOneWithoutGamesNestedInput
    users_games_white_player_idTousers?: usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput
  }

  export type gamesUncheckedUpdateWithoutWebsocket_connectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type usersUpsertWithoutWebsocket_connectionsInput = {
    update: XOR<usersUpdateWithoutWebsocket_connectionsInput, usersUncheckedUpdateWithoutWebsocket_connectionsInput>
    create: XOR<usersCreateWithoutWebsocket_connectionsInput, usersUncheckedCreateWithoutWebsocket_connectionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWebsocket_connectionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWebsocket_connectionsInput, usersUncheckedUpdateWithoutWebsocket_connectionsInput>
  }

  export type usersUpdateWithoutWebsocket_connectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutWebsocket_connectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    elo?: IntFieldUpdateOperationsInput | number
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: analysesUncheckedUpdateManyWithoutUsersNestedInput
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutUsersNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutUsersNestedInput
    games_games_black_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersNestedInput
    games_games_white_player_idTousers?: gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutUsersNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutUsersNestedInput
    tournaments?: tournamentsUncheckedUpdateManyWithoutUsersNestedInput
    user_analytics?: user_analyticsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type chat_messagesCreateManyGamesInput = {
    id: string
    user_id?: string | null
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type game_movesCreateManyGamesInput = {
    id: string
    user_id?: string | null
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
  }

  export type websocket_connectionsCreateManyGamesInput = {
    id: string
    connection_id: string
    user_id: string
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
  }

  export type chat_messagesUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutChat_messagesNestedInput
  }

  export type chat_messagesUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutGame_movesNestedInput
  }

  export type game_movesUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUncheckedUpdateManyWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type websocket_connectionsUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneRequiredWithoutWebsocket_connectionsNestedInput
  }

  export type websocket_connectionsUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type gamesCreateManyTournamentsInput = {
    id: string
    white_player_id?: string | null
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
  }

  export type tournament_participantsCreateManyTournamentsInput = {
    id: string
    user_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type gamesUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUpdateManyWithoutGamesNestedInput
    users_games_black_player_idTousers?: usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput
    users_games_white_player_idTousers?: usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateManyWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
  }

  export type tournament_participantsUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutTournament_participantsNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_participantsUncheckedUpdateManyWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type analysesCreateManyUsersInput = {
    id: string
    board_state: string
    dice?: analysesCreatediceInput | number[]
    move: string
    best_move: string
    equity: number
    pr: number
    explanation: string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: $Enums.AnalysisType
    createdAt?: Date | string
  }

  export type chat_messagesCreateManyUsersInput = {
    id: string
    game_id: string
    message: string
    message_type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type game_movesCreateManyUsersInput = {
    id: string
    game_id: string
    player: $Enums.Player
    dice?: game_movesCreatediceInput | number[]
    move: string
    from_point?: number | null
    to_point?: number | null
    equity?: number | null
    pr?: number | null
    thinking_time?: number | null
    createdAt?: Date | string
  }

  export type gamesCreateManyUsers_games_black_player_idTousersInput = {
    id: string
    white_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
  }

  export type gamesCreateManyUsers_games_white_player_idTousersInput = {
    id: string
    black_player_id?: string | null
    status?: $Enums.GameStatus
    board_state?: string
    gameMode?: $Enums.GameMode
    current_player?: $Enums.Player
    dice?: gamesCreatediceInput | number[]
    white_score?: number
    black_score?: number
    createdAt?: Date | string
    finished_at?: Date | string | null
    winner?: $Enums.Player | null
    tournament_id?: string | null
  }

  export type tournament_participantsCreateManyUsersInput = {
    id: string
    tournament_id: string
    registered_at?: Date | string
    current_position?: number | null
    eliminated_at?: Date | string | null
  }

  export type tournamentsCreateManyUsersInput = {
    id: string
    name: string
    description?: string | null
    entryFee?: number
    prizePool?: number
    maxPlayers?: number | null
    status?: $Enums.TournamentStatus
    start_time?: Date | string | null
    end_time?: Date | string | null
    createdAt?: Date | string
  }

  export type user_analyticsCreateManyUsersInput = {
    id: string
    date?: Date | string
    games_played?: number
    games_won?: number
    analyses_completed?: number
    time_played?: number
    avg_equity?: number
    elo_change?: number
    createdAt?: Date | string
  }

  export type websocket_connectionsCreateManyUsersInput = {
    id: string
    connection_id: string
    game_id?: string | null
    connected_at?: Date | string
    last_ping?: Date | string
    is_active?: boolean
  }

  export type analysesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analysesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    board_state?: StringFieldUpdateOperationsInput | string
    dice?: analysesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    best_move?: StringFieldUpdateOperationsInput | string
    equity?: FloatFieldUpdateOperationsInput | number
    pr?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    alternatives?: JsonNullValueInput | InputJsonValue
    analysis_type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateOneRequiredWithoutChat_messagesNestedInput
  }

  export type chat_messagesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    message_type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateOneRequiredWithoutGame_movesNestedInput
  }

  export type game_movesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type game_movesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    game_id?: StringFieldUpdateOperationsInput | string
    player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: game_movesUpdatediceInput | number[]
    move?: StringFieldUpdateOperationsInput | string
    from_point?: NullableIntFieldUpdateOperationsInput | number | null
    to_point?: NullableIntFieldUpdateOperationsInput | number | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    pr?: NullableFloatFieldUpdateOperationsInput | number | null
    thinking_time?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type gamesUpdateWithoutUsers_games_black_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUpdateManyWithoutGamesNestedInput
    tournaments?: tournamentsUpdateOneWithoutGamesNestedInput
    users_games_white_player_idTousers?: usersUpdateOneWithoutGames_games_white_player_idTousersNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateWithoutUsers_games_black_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateManyWithoutUsers_games_black_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    white_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gamesUpdateWithoutUsers_games_white_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    chat_messages?: chat_messagesUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUpdateManyWithoutGamesNestedInput
    users_games_black_player_idTousers?: usersUpdateOneWithoutGames_games_black_player_idTousersNestedInput
    tournaments?: tournamentsUpdateOneWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateWithoutUsers_games_white_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutGamesNestedInput
    game_moves?: game_movesUncheckedUpdateManyWithoutGamesNestedInput
    websocket_connections?: websocket_connectionsUncheckedUpdateManyWithoutGamesNestedInput
  }

  export type gamesUncheckedUpdateManyWithoutUsers_games_white_player_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    black_player_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    board_state?: StringFieldUpdateOperationsInput | string
    gameMode?: EnumGameModeFieldUpdateOperationsInput | $Enums.GameMode
    current_player?: EnumPlayerFieldUpdateOperationsInput | $Enums.Player
    dice?: gamesUpdatediceInput | number[]
    white_score?: IntFieldUpdateOperationsInput | number
    black_score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winner?: NullableEnumPlayerFieldUpdateOperationsInput | $Enums.Player | null
    tournament_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tournament_participantsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournaments?: tournamentsUpdateOneRequiredWithoutTournament_participantsNestedInput
  }

  export type tournament_participantsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournament_participantsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournament_id?: StringFieldUpdateOperationsInput | string
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    current_position?: NullableIntFieldUpdateOperationsInput | number | null
    eliminated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tournamentsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUpdateManyWithoutTournamentsNestedInput
    tournament_participants?: tournament_participantsUpdateManyWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: gamesUncheckedUpdateManyWithoutTournamentsNestedInput
    tournament_participants?: tournament_participantsUncheckedUpdateManyWithoutTournamentsNestedInput
  }

  export type tournamentsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: IntFieldUpdateOperationsInput | number
    prizePool?: IntFieldUpdateOperationsInput | number
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_analyticsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    games_played?: IntFieldUpdateOperationsInput | number
    games_won?: IntFieldUpdateOperationsInput | number
    analyses_completed?: IntFieldUpdateOperationsInput | number
    time_played?: IntFieldUpdateOperationsInput | number
    avg_equity?: FloatFieldUpdateOperationsInput | number
    elo_change?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type websocket_connectionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    games?: gamesUpdateOneWithoutWebsocket_connectionsNestedInput
  }

  export type websocket_connectionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    game_id?: NullableStringFieldUpdateOperationsInput | string | null
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type websocket_connectionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    connection_id?: StringFieldUpdateOperationsInput | string
    game_id?: NullableStringFieldUpdateOperationsInput | string | null
    connected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_ping?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use GamesCountOutputTypeDefaultArgs instead
     */
    export type GamesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentsCountOutputTypeDefaultArgs instead
     */
    export type TournamentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use analysesDefaultArgs instead
     */
    export type analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = analysesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use chat_messagesDefaultArgs instead
     */
    export type chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = chat_messagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use game_movesDefaultArgs instead
     */
    export type game_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = game_movesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gamesDefaultArgs instead
     */
    export type gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = gamesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subscriptionsDefaultArgs instead
     */
    export type subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = subscriptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tournament_participantsDefaultArgs instead
     */
    export type tournament_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tournament_participantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tournamentsDefaultArgs instead
     */
    export type tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tournamentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_analyticsDefaultArgs instead
     */
    export type user_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_analyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use websocket_connectionsDefaultArgs instead
     */
    export type websocket_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = websocket_connectionsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}